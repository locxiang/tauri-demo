# 代码结构

## 📁 整体目录结构

```
big-data-rpa-v4/
├── docs/                          # 项目文档
├── src/                           # 前端源码 (Vue.js)
├── src-tauri/                     # 后端源码 (Rust)
├── public/                        # 静态资源
├── tests/                         # 测试文件
├── package.json                   # 前端依赖管理
├── pnpm-lock.yaml                # 依赖锁定文件
├── vite.config.ts                # Vite 配置
├── tailwind.config.cjs           # TailwindCSS 配置
├── tsconfig.json                 # TypeScript 配置
└── README.md                     # 项目说明
```

## 🎨 前端代码结构

### 目录架构
```
src/
├── App.vue                       # 根组件
├── main.ts                       # 应用入口点
├── router.ts                     # 路由配置
├── assets/                       # 静态资源
│   ├── icons/                   # SVG 图标
│   │   ├── http-request.svg
│   │   ├── http-response.svg
│   │   └── network-packet.svg
│   └── main.css                 # 全局样式
├── components/                   # 公共组件
│   └── NetworkDeviceComponent.vue
├── stores/                       # 状态管理 (Pinia)
│   ├── index.ts                 # Store 导出
│   ├── appStore.ts              # 应用状态
│   ├── authStore.ts             # 认证状态
│   └── proxyStore.ts            # 代理抓包状态
├── views/                        # 页面组件
│   ├── Dashboard/               # 控制台页面
│   │   └── index.vue
│   ├── ProxyController/         # 代理控制器
│   │   ├── index.vue
│   │   ├── animations.css
│   │   └── components/
│   │       ├── PacketFilter.vue
│   │       └── PacketTable.vue
│   ├── PacketWindows/           # 数据包详情窗口
│   │   ├── index.vue
│   │   └── components/
│   │       └── PacketDetail.vue
│   ├── SystemPermissions/       # 系统权限管理
│   │   ├── index.vue
│   │   └── animations.css
│   └── SystemLogs/              # 系统日志
│       └── index.vue
├── auto-imports.d.ts            # 自动导入类型声明
├── env.d.ts                     # 环境变量类型
└── vite-env.d.ts                # Vite 环境类型
```

### 组件分层架构

#### 1. App.vue - 根组件
```vue
<template>
  <div id="app">
    <router-view />
  </div>
</template>

<script setup>
// 初始化所有 Store
import { useAppStore, useAuthStore, useProxyStore } from './stores'

onMounted(async () => {
  // 并行初始化所有 Store
  await Promise.all([
    appStore.initialize(),
    authStore.initialize(),
    proxyStore.initialize()
  ])
})
</script>
```

#### 2. 路由配置 (router.ts)
```typescript
const routes = [
  { path: "/", name: "Dashboard", component: Dashboard },
  { path: "/proxy", name: "ProxyController", component: ProxyController },
  { path: "/packet-detail/:id", name: "PacketDetail", component: PacketDetailWindow },
  { path: "/permissions", name: "SystemPermissions", component: SystemPermissions },
  { path: "/logs", name: "SystemLogs", component: SystemLogs }
]
```

#### 3. 状态管理架构 (stores/)
```typescript
// appStore.ts - 应用基础状态
export const useAppStore = defineStore('app', {
  state: () => ({
    debug: false,
    version: '0.7.0',
    isInitialized: false,
    startTime: 0,
    currentUptime: 0
  }),
  
  actions: {
    async initialize() { /* 初始化逻辑 */ },
    updateUptime() { /* 更新运行时间 */ }
  }
})

// authStore.ts - 认证状态管理
export const useAuthStore = defineStore('auth', {
  state: () => ({
    tokenStatus: [] as TokenStatus[],
    tokenEvents: [] as TokenEvent[]
  }),
  
  actions: {
    async initialize() { /* 设置 Token 事件监听 */ },
    async refreshTokenStatus() { /* 刷新 Token 状态 */ }
  }
})

// proxyStore.ts - 网络抓包状态
export const useProxyStore = defineStore('proxy', {
  state: () => ({
    captureStatus: null as CaptureStatus | null,
    packets: [] as PacketData[],
    networkDevices: [] as NetworkDevice[]
  }),
  
  actions: {
    async initialize() { /* 初始化抓包系统 */ },
    async startCapture(deviceName: string) { /* 开始抓包 */ }
  }
})
```

## ⚙️ 后端代码结构

### 目录架构 (DDD架构)
```
src-tauri/
├── Cargo.toml                    # Rust 项目配置
├── Cargo.lock                    # 依赖锁定
├── tauri.conf.json              # Tauri 配置
├── build.rs                     # 构建脚本
├── src/                         # Rust 源码
│   ├── main.rs                  # 程序入口
│   ├── lib.rs                   # 库入口和应用初始化
│   ├── app/                     # 应用层 (Application Layer)
│   │   ├── mod.rs               # 应用层模块导出
│   │   ├── config.rs            # 应用配置管理
│   │   ├── error.rs             # 统一错误处理
│   │   ├── state.rs             # 全局应用状态
│   │   ├── setup.rs             # 应用初始化流程
│   │   └── logging.rs           # 现代化日志系统核心
│   ├── api/                     # API层 (Interface Layer)
│   │   ├── mod.rs               # API统一导出
│   │   ├── logging.rs           # 日志API接口
│   │   ├── capture.rs           # 捕获API接口
│   │   ├── auth.rs              # 认证API接口
│   │   ├── system.rs            # 系统API接口
│   │   └── window.rs            # 窗口API接口
│   ├── domain/                  # 领域层 (Domain Layer)
│   │   ├── mod.rs               # 领域层导出
│   │   ├── auth/                # 认证领域
│   │   │   ├── mod.rs           # 认证领域导出
│   │   │   ├── entities.rs      # 认证实体
│   │   │   └── systems/         # 认证系统实现
│   │   │       └── mod.rs
│   │   ├── capture/             # 捕获领域
│   │   │   ├── mod.rs           # 捕获领域导出
│   │   │   └── entities.rs      # 捕获实体
│   │   └── shared/              # 共享领域
│   │       └── mod.rs           # 共享模型
│   ├── infrastructure/          # 基础设施层 (Infrastructure Layer)
│   │   ├── mod.rs               # 基础设施导出
│   │   ├── logging/             # 日志基础设施
│   │   │   └── mod.rs
│   │   ├── network/             # 网络基础设施
│   │   │   └── mod.rs
│   │   ├── storage/             # 存储基础设施
│   │   │   └── mod.rs
│   │   └── system/              # 系统基础设施
│   │       └── mod.rs
│   ├── auth/                    # 认证系统 (现有实现)
│   │   ├── mod.rs               # 认证模块入口
│   │   ├── manager.rs           # 认证管理器
│   │   ├── store.rs             # Token 存储
│   │   └── systems/             # 各系统认证实现
│   │       ├── mod.rs
│   │       ├── registry.rs      # 系统注册中心
│   │       ├── system_test.rs   # 测试系统认证
│   │       ├── system_bi.rs     # BI 系统认证
│   │       ├── system_three.rs  # 三级治理中心认证
│   │       ├── system_drs.rs    # DRS 系统认证
│   │       └── 协议/            # 协议文件(预留)
│   ├── capture/                 # 网络抓包模块 (现有实现)
│   │   ├── mod.rs               # 抓包模块入口
│   │   └── capture.rs           # 抓包实现
│   ├── utils/                   # 工具库
│   │   ├── mod.rs               # 工具模块导出
│   │   ├── crypto.rs            # 加密工具
│   │   ├── parser.rs            # 解析工具
│   │   ├── time.rs              # 时间工具
│   │   └── validation.rs        # 验证工具
│   ├── tests/                   # 测试目录
│   │   ├── integration/         # 集成测试
│   │   └── unit/                # 单元测试
│   └── cmd.rs                   # 旧版命令处理(待迁移)
└── target/                      # 编译输出目录
```

### 模块架构详解

#### 1. 应用入口 (lib.rs)
```rust
// 应用核心模块
pub mod app;
pub mod api;
pub mod domain;
pub mod infrastructure;
pub mod utils;

// 保留原有模块以便渐进式迁移
mod capture;
mod auth;
mod cmd;

use log::{error, info, warn};
use app::AppSetup;
use tauri::Manager;

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    // 初始化现代化日志系统
    if let Err(e) = app::init_log_system() {
        eprintln!("❌ 初始化日志系统失败: {}", e);
    } else {
        println!("✅ 现代化日志系统初始化成功");
    }
    
    info!("🚀 启动数字重庆业务数据巡查自动化系统 v{}", env!("CARGO_PKG_VERSION"));
    
    tauri::Builder::default()
        .plugin(tauri_plugin_shell::init())
        .plugin(tauri_plugin_prevent_default::init())
        .invoke_handler(tauri::generate_handler![
            // 新的API接口
            api::get_capture_status,
            api::init_capture,
            api::stop_capture,
            api::get_network_devices,
            api::get_all_token_status,
            api::get_system_token,
            // 现代化日志系统命令
            api::get_recent_logs,
            api::subscribe_log_stream,
            api::unsubscribe_log_stream,
            api::clear_logs,
            api::get_log_stats,
        ])
        .setup(|app| {
            // 使用新的初始化流程
            let rt = tokio::runtime::Runtime::new().expect("Failed to create Tokio runtime");
            
            match rt.block_on(async {
                // 初始化应用状态
                let app_state = AppSetup::initialize().await?;
                
                // 将应用状态存储到Tauri的状态管理中
                app.manage(app_state);
                
                // 初始化旧的系统以保持兼容性
                init_legacy_systems(app.handle().clone()).await?;
                
                Ok::<(), app::AppError>(())
            }) {
                Ok(_) => info!("✅ 应用程序初始化完成"),
                Err(e) => {
                    error!("❌ 应用程序初始化失败: {}", e);
                    return Err(Box::new(e));
                }
            }
            
            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

#### 2. API层架构 (api/)
```rust
// api/mod.rs - API统一导出
pub mod capture;
pub mod auth;
pub mod system;
pub mod window;
pub mod logging;

// 重新导出所有API命令
pub use capture::*;
pub use auth::*;
pub use system::*;
pub use window::*;
pub use logging::*;

// api/logging.rs - 日志API实现
use tauri::{State, Window};
use crate::app::logging::{get_log_system, LogFilters, LogEntry};

#[tauri::command]
pub async fn get_recent_logs(
    limit: Option<usize>,
    filters: Option<LogFilters>,
    _state: State<'_, crate::app::AppState>
) -> Result<Vec<LogEntry>, String> {
    log::info!("📋 获取最近日志，限制: {:?}", limit);
    
    if let Some(log_system) = get_log_system() {
        let logs = log_system.get_recent_logs(limit.unwrap_or(1000), filters);
        Ok(logs)
    } else {
        Err("日志系统未初始化".to_string())
    }
}

#[tauri::command]
pub async fn subscribe_log_stream(
    window: Window,
    filters: Option<LogFilters>,
    _state: State<'_, crate::app::AppState>
) -> Result<(), String> {
    if let Some(log_system) = get_log_system() {
        let filters = filters.unwrap_or_default();
        log_system.add_subscriber(window, filters);
        Ok(())
    } else {
        Err("日志系统未初始化".to_string())
    }
}

// api/capture.rs - 捕获API实现
#[tauri::command]
pub async fn get_capture_status() -> Result<CaptureStatus, String> {
    crate::capture::get_capture_status().map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn init_capture(device_name: String) -> Result<(), String> {
    crate::capture::start_capture(&device_name).map_err(|e| e.to_string())
}
```

#### 3. 应用层架构 (app/)
```rust
// app/mod.rs - 应用层模块导出
pub mod config;
pub mod error;
pub mod state;
pub mod setup;
pub mod logging;

// 重新导出重要的类型
pub use config::AppConfig;
pub use error::{AppError, AppResult, NetworkError, AuthError};
pub use state::AppState;
pub use setup::AppSetup;
pub use logging::{init_log_system, get_log_system, LogEntry, LogLevel, LogFilters};

// app/logging.rs - 现代化日志系统核心
use std::collections::HashMap;
use std::sync::{Arc, RwLock, atomic::{AtomicU64, Ordering}};
use serde::{Serialize, Deserialize};
use tokio::sync::broadcast;
use chrono::Utc;
use once_cell::sync::OnceCell;
use tauri::Emitter;

/// 现代化日志系统
pub struct ModernLogSystem {
    /// 环形缓冲区
    pub buffer: Arc<RwLock<CircularBuffer<LogEntry>>>,
    /// 广播发送器
    broadcaster: broadcast::Sender<LogEntry>,
    /// ID生成器
    id_counter: AtomicU64,
    /// 订阅者列表
    subscribers: Arc<RwLock<Vec<LogSubscriber>>>,
}

impl ModernLogSystem {
    pub fn new(buffer_capacity: usize) -> Self {
        let (sender, _) = broadcast::channel(1000);
        
        Self {
            buffer: Arc::new(RwLock::new(CircularBuffer::new(buffer_capacity))),
            broadcaster: sender,
            id_counter: AtomicU64::new(1),
            subscribers: Arc::new(RwLock::new(Vec::new())),
        }
    }
    
    /// 添加日志条目
    pub fn add_log(&self, entry: LogEntry) {
        // 存储到环形缓冲区
        {
            let mut buffer = self.buffer.write().unwrap();
            buffer.push(entry.clone());
        }
        
        // 广播给订阅者
        let _ = self.broadcaster.send(entry.clone());
        
        // 推送给前端订阅者
        self.notify_subscribers(&entry);
    }
}

// app/setup.rs - 应用初始化
pub struct AppSetup;

impl AppSetup {
    pub async fn initialize() -> Result<AppState, AppError> {
        // 初始化应用状态
        let state = AppState::new().await?;
        
        // 执行其他初始化任务
        Self::setup_logging().await?;
        Self::setup_configurations().await?;
        
        Ok(state)
    }
    
    async fn setup_logging() -> Result<(), AppError> {
        // 初始化日志系统
        init_log_system().map_err(|e| AppError::InitializationError(e.to_string()))?;
        Ok(())
    }
    
    async fn setup_configurations() -> Result<(), AppError> {
        // 加载配置文件
        // 验证系统权限
        // 初始化网络组件
        Ok(())
    }
}
```

#### 4. 网络抓包模块 (capture/)
```rust
// capture.rs - 抓包实现
pub struct CaptureStatus {
    pub is_running: bool,
    pub packets_captured: u64,
    pub bytes_captured: u64,
    pub start_time: Option<u64>,
    pub device_name: Option<String>,
}

pub async fn start_capture(device_name: &str) -> Result<()> {
    // 1. 初始化网络设备
    let device = Device::lookup().unwrap()
        .find(|d| d.name == device_name)
        .ok_or_else(|| anyhow!("设备不存在"))?;
    
    // 2. 创建抓包实例
    let mut cap = Capture::from_device(device)?
        .promisc(true)
        .snaplen(65535)
        .timeout(1000)
        .open()?;
    
    // 3. 设置过滤器
    cap.filter("tcp port 80 or tcp port 8080 or tcp port 443", true)?;
    
    // 4. 开始抓包循环
    while let Ok(packet) = cap.next_packet() {
        process_packet(packet).await?;
    }
    
    Ok(())
}

async fn process_packet(packet: Packet) -> Result<()> {
    // 1. 解析以太网帧
    let ethernet = EthernetSlice::from_slice(&packet.data)?;
    
    // 2. 解析IP层
    let ip = match ethernet.payload() {
        EtherPayload::Ipv4(header, payload) => (header, payload),
        _ => return Ok(()),
    };
    
    // 3. 解析TCP层
    let tcp = TcpSlice::from_slice(ip.1)?;
    
    // 4. 解析HTTP层
    if let Some(http_packet) = parse_http_packet(&tcp.payload()) {
        send_http_packet(http_packet).await?;
        auth::process_http_packet(&http_packet).await?;
    }
    
    Ok(())
}
```

## 🔧 配置文件结构

### 1. Tauri 配置 (tauri.conf.json)
```json
{
  "productName": "数字重庆业务数据巡查自动化系统",
  "version": "0.7.0",
  "identifier": "com.sumi.big-data-rpa-v4",
  "app": {
    "windows": [
      {
        "title": "数字重庆业务数据巡查自动化系统",
        "width": 1200,
        "height": 800,
        "minWidth": 800,
        "minHeight": 600
      }
    ]
  },
  "permissions": [
    "core:default",
    "shell:allow-open",
    "log:default"
  ]
}
```

### 2. 前端配置文件
```typescript
// vite.config.ts - Vite 配置
export default defineConfig({
  plugins: [
    vue(),
    AutoImport({
      imports: ['vue', 'vue-router', 'pinia'],
      dts: true
    }),
    Components({
      dts: true
    })
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  }
})

// tailwind.config.cjs - TailwindCSS 配置
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{vue,js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: '#2563eb',
        secondary: '#64748b'
      }
    }
  }
}
```

### 3. TypeScript 配置
```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

## 📦 依赖管理

### 前端依赖 (package.json)
```json
{
  "dependencies": {
    "@tauri-apps/api": "^2.6.0",
    "pinia": "^3.0.3",
    "vue": "^3.5.17",
    "vue-router": "^4.5.1",
    "pako": "^2.1.0"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^6.0.0",
    "typescript": "^5.8.3",
    "vite": "^7.0.0",
    "tailwindcss": "^4.1.10"
  }
}
```

### 后端依赖 (Cargo.toml)
```toml
[dependencies]
tauri = { version = "2", features = ["devtools"] }
serde = { version = "1", features = ["derive"] }
tokio = { version = "1.40", features = ["full"] }
pcap = "2.2.0"
etherparse = "0.18.0"
anyhow = "1.0.98"
log = "0.4.27"
chrono = { version = "0.4", features = ["serde"] }
dashmap = "6.1"
```

## 🔄 数据流架构

### 前端数据流
```
用户操作 → 组件事件 → Store Action → Tauri Command → Rust 处理
    ↑                                                    ↓
UI 更新 ← Store State ← Channel Event ← Rust 后台任务
```

### 后端数据流
```
网络数据包 → 协议解析 → HTTP 识别 → Token 提取 → 状态更新 → 前端推送
```

## 🧪 测试结构

### 测试目录
```
tests/
├── setup/                       # 测试环境设置
│   ├── install-pinia.ts        # Pinia 测试配置
│   └── testglobals.ts          # 测试全局配置
└── unit/                       # 单元测试
    └── example.test.ts         # 示例测试
```

### 测试配置
```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    environment: 'jsdom',
    setupFiles: ['./tests/setup/install-pinia.ts'],
    globals: true
  }
})
```

这个代码结构展现了一个现代化的桌面应用架构，前后端分离，模块化清晰，便于维护和扩展。