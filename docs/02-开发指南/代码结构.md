# ä»£ç ç»“æ„

## ğŸ“ æ•´ä½“ç›®å½•ç»“æ„

```
big-data-rpa-v4/
â”œâ”€â”€ docs/                          # é¡¹ç›®æ–‡æ¡£
â”œâ”€â”€ src/                           # å‰ç«¯æºç  (Vue.js)
â”œâ”€â”€ src-tauri/                     # åç«¯æºç  (Rust)
â”œâ”€â”€ public/                        # é™æ€èµ„æº
â”œâ”€â”€ tests/                         # æµ‹è¯•æ–‡ä»¶
â”œâ”€â”€ package.json                   # å‰ç«¯ä¾èµ–ç®¡ç†
â”œâ”€â”€ pnpm-lock.yaml                # ä¾èµ–é”å®šæ–‡ä»¶
â”œâ”€â”€ vite.config.ts                # Vite é…ç½®
â”œâ”€â”€ tailwind.config.cjs           # TailwindCSS é…ç½®
â”œâ”€â”€ tsconfig.json                 # TypeScript é…ç½®
â””â”€â”€ README.md                     # é¡¹ç›®è¯´æ˜
```

## ğŸ¨ å‰ç«¯ä»£ç ç»“æ„

### ç›®å½•æ¶æ„
```
src/
â”œâ”€â”€ App.vue                       # æ ¹ç»„ä»¶
â”œâ”€â”€ main.ts                       # åº”ç”¨å…¥å£ç‚¹
â”œâ”€â”€ router.ts                     # è·¯ç”±é…ç½®
â”œâ”€â”€ assets/                       # é™æ€èµ„æº
â”‚   â”œâ”€â”€ icons/                   # SVG å›¾æ ‡
â”‚   â”‚   â”œâ”€â”€ http-request.svg
â”‚   â”‚   â”œâ”€â”€ http-response.svg
â”‚   â”‚   â””â”€â”€ network-packet.svg
â”‚   â””â”€â”€ main.css                 # å…¨å±€æ ·å¼
â”œâ”€â”€ components/                   # å…¬å…±ç»„ä»¶
â”‚   â””â”€â”€ NetworkDeviceComponent.vue
â”œâ”€â”€ stores/                       # çŠ¶æ€ç®¡ç† (Pinia)
â”‚   â”œâ”€â”€ index.ts                 # Store å¯¼å‡º
â”‚   â”œâ”€â”€ appStore.ts              # åº”ç”¨çŠ¶æ€
â”‚   â”œâ”€â”€ authStore.ts             # è®¤è¯çŠ¶æ€
â”‚   â””â”€â”€ proxyStore.ts            # ä»£ç†æŠ“åŒ…çŠ¶æ€
â”œâ”€â”€ views/                        # é¡µé¢ç»„ä»¶
â”‚   â”œâ”€â”€ Dashboard/               # æ§åˆ¶å°é¡µé¢
â”‚   â”‚   â””â”€â”€ index.vue
â”‚   â”œâ”€â”€ ProxyController/         # ä»£ç†æ§åˆ¶å™¨
â”‚   â”‚   â”œâ”€â”€ index.vue
â”‚   â”‚   â”œâ”€â”€ animations.css
â”‚   â”‚   â””â”€â”€ components/
â”‚   â”‚       â”œâ”€â”€ PacketFilter.vue
â”‚   â”‚       â””â”€â”€ PacketTable.vue
â”‚   â”œâ”€â”€ PacketWindows/           # æ•°æ®åŒ…è¯¦æƒ…çª—å£
â”‚   â”‚   â”œâ”€â”€ index.vue
â”‚   â”‚   â””â”€â”€ components/
â”‚   â”‚       â””â”€â”€ PacketDetail.vue
â”‚   â”œâ”€â”€ SystemPermissions/       # ç³»ç»Ÿæƒé™ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ index.vue
â”‚   â”‚   â””â”€â”€ animations.css
â”‚   â””â”€â”€ SystemLogs/              # ç³»ç»Ÿæ—¥å¿—
â”‚       â””â”€â”€ index.vue
â”œâ”€â”€ auto-imports.d.ts            # è‡ªåŠ¨å¯¼å…¥ç±»å‹å£°æ˜
â”œâ”€â”€ env.d.ts                     # ç¯å¢ƒå˜é‡ç±»å‹
â””â”€â”€ vite-env.d.ts                # Vite ç¯å¢ƒç±»å‹
```

### ç»„ä»¶åˆ†å±‚æ¶æ„

#### 1. App.vue - æ ¹ç»„ä»¶
```vue
<template>
  <div id="app">
    <router-view />
  </div>
</template>

<script setup>
// åˆå§‹åŒ–æ‰€æœ‰ Store
import { useAppStore, useAuthStore, useProxyStore } from './stores'

onMounted(async () => {
  // å¹¶è¡Œåˆå§‹åŒ–æ‰€æœ‰ Store
  await Promise.all([
    appStore.initialize(),
    authStore.initialize(),
    proxyStore.initialize()
  ])
})
</script>
```

#### 2. è·¯ç”±é…ç½® (router.ts)
```typescript
const routes = [
  { path: "/", name: "Dashboard", component: Dashboard },
  { path: "/proxy", name: "ProxyController", component: ProxyController },
  { path: "/packet-detail/:id", name: "PacketDetail", component: PacketDetailWindow },
  { path: "/permissions", name: "SystemPermissions", component: SystemPermissions },
  { path: "/logs", name: "SystemLogs", component: SystemLogs }
]
```

#### 3. çŠ¶æ€ç®¡ç†æ¶æ„ (stores/)
```typescript
// appStore.ts - åº”ç”¨åŸºç¡€çŠ¶æ€
export const useAppStore = defineStore('app', {
  state: () => ({
    debug: false,
    version: '0.7.0',
    isInitialized: false,
    startTime: 0,
    currentUptime: 0
  }),
  
  actions: {
    async initialize() { /* åˆå§‹åŒ–é€»è¾‘ */ },
    updateUptime() { /* æ›´æ–°è¿è¡Œæ—¶é—´ */ }
  }
})

// authStore.ts - è®¤è¯çŠ¶æ€ç®¡ç†
export const useAuthStore = defineStore('auth', {
  state: () => ({
    tokenStatus: [] as TokenStatus[],
    tokenEvents: [] as TokenEvent[]
  }),
  
  actions: {
    async initialize() { /* è®¾ç½® Token äº‹ä»¶ç›‘å¬ */ },
    async refreshTokenStatus() { /* åˆ·æ–° Token çŠ¶æ€ */ }
  }
})

// proxyStore.ts - ç½‘ç»œæŠ“åŒ…çŠ¶æ€
export const useProxyStore = defineStore('proxy', {
  state: () => ({
    captureStatus: null as CaptureStatus | null,
    packets: [] as PacketData[],
    networkDevices: [] as NetworkDevice[]
  }),
  
  actions: {
    async initialize() { /* åˆå§‹åŒ–æŠ“åŒ…ç³»ç»Ÿ */ },
    async startCapture(deviceName: string) { /* å¼€å§‹æŠ“åŒ… */ }
  }
})
```

## âš™ï¸ åç«¯ä»£ç ç»“æ„

### ç›®å½•æ¶æ„ (DDDæ¶æ„)
```
src-tauri/
â”œâ”€â”€ Cargo.toml                    # Rust é¡¹ç›®é…ç½®
â”œâ”€â”€ Cargo.lock                    # ä¾èµ–é”å®š
â”œâ”€â”€ tauri.conf.json              # Tauri é…ç½®
â”œâ”€â”€ build.rs                     # æ„å»ºè„šæœ¬
â”œâ”€â”€ src/                         # Rust æºç 
â”‚   â”œâ”€â”€ main.rs                  # ç¨‹åºå…¥å£
â”‚   â”œâ”€â”€ lib.rs                   # åº“å…¥å£å’Œåº”ç”¨åˆå§‹åŒ–
â”‚   â”œâ”€â”€ app/                     # åº”ç”¨å±‚ (Application Layer)
â”‚   â”‚   â”œâ”€â”€ mod.rs               # åº”ç”¨å±‚æ¨¡å—å¯¼å‡º
â”‚   â”‚   â”œâ”€â”€ config.rs            # åº”ç”¨é…ç½®ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ error.rs             # ç»Ÿä¸€é”™è¯¯å¤„ç†
â”‚   â”‚   â”œâ”€â”€ state.rs             # å…¨å±€åº”ç”¨çŠ¶æ€
â”‚   â”‚   â”œâ”€â”€ setup.rs             # åº”ç”¨åˆå§‹åŒ–æµç¨‹
â”‚   â”‚   â””â”€â”€ logging.rs           # ç°ä»£åŒ–æ—¥å¿—ç³»ç»Ÿæ ¸å¿ƒ
â”‚   â”œâ”€â”€ api/                     # APIå±‚ (Interface Layer)
â”‚   â”‚   â”œâ”€â”€ mod.rs               # APIç»Ÿä¸€å¯¼å‡º
â”‚   â”‚   â”œâ”€â”€ logging.rs           # æ—¥å¿—APIæ¥å£
â”‚   â”‚   â”œâ”€â”€ capture.rs           # æ•è·APIæ¥å£
â”‚   â”‚   â”œâ”€â”€ auth.rs              # è®¤è¯APIæ¥å£
â”‚   â”‚   â”œâ”€â”€ system.rs            # ç³»ç»ŸAPIæ¥å£
â”‚   â”‚   â””â”€â”€ window.rs            # çª—å£APIæ¥å£
â”‚   â”œâ”€â”€ domain/                  # é¢†åŸŸå±‚ (Domain Layer)
â”‚   â”‚   â”œâ”€â”€ mod.rs               # é¢†åŸŸå±‚å¯¼å‡º
â”‚   â”‚   â”œâ”€â”€ auth/                # è®¤è¯é¢†åŸŸ
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs           # è®¤è¯é¢†åŸŸå¯¼å‡º
â”‚   â”‚   â”‚   â”œâ”€â”€ entities.rs      # è®¤è¯å®ä½“
â”‚   â”‚   â”‚   â””â”€â”€ systems/         # è®¤è¯ç³»ç»Ÿå®ç°
â”‚   â”‚   â”‚       â””â”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ capture/             # æ•è·é¢†åŸŸ
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs           # æ•è·é¢†åŸŸå¯¼å‡º
â”‚   â”‚   â”‚   â””â”€â”€ entities.rs      # æ•è·å®ä½“
â”‚   â”‚   â””â”€â”€ shared/              # å…±äº«é¢†åŸŸ
â”‚   â”‚       â””â”€â”€ mod.rs           # å…±äº«æ¨¡å‹
â”‚   â”œâ”€â”€ infrastructure/          # åŸºç¡€è®¾æ–½å±‚ (Infrastructure Layer)
â”‚   â”‚   â”œâ”€â”€ mod.rs               # åŸºç¡€è®¾æ–½å¯¼å‡º
â”‚   â”‚   â”œâ”€â”€ logging/             # æ—¥å¿—åŸºç¡€è®¾æ–½
â”‚   â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ network/             # ç½‘ç»œåŸºç¡€è®¾æ–½
â”‚   â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ storage/             # å­˜å‚¨åŸºç¡€è®¾æ–½
â”‚   â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ system/              # ç³»ç»ŸåŸºç¡€è®¾æ–½
â”‚   â”‚       â””â”€â”€ mod.rs
â”‚   â”œâ”€â”€ auth/                    # è®¤è¯ç³»ç»Ÿ (ç°æœ‰å®ç°)
â”‚   â”‚   â”œâ”€â”€ mod.rs               # è®¤è¯æ¨¡å—å…¥å£
â”‚   â”‚   â”œâ”€â”€ manager.rs           # è®¤è¯ç®¡ç†å™¨
â”‚   â”‚   â”œâ”€â”€ store.rs             # Token å­˜å‚¨
â”‚   â”‚   â””â”€â”€ systems/             # å„ç³»ç»Ÿè®¤è¯å®ç°
â”‚   â”‚       â”œâ”€â”€ mod.rs
â”‚   â”‚       â”œâ”€â”€ registry.rs      # ç³»ç»Ÿæ³¨å†Œä¸­å¿ƒ
â”‚   â”‚       â”œâ”€â”€ system_test.rs   # æµ‹è¯•ç³»ç»Ÿè®¤è¯
â”‚   â”‚       â”œâ”€â”€ system_bi.rs     # BI ç³»ç»Ÿè®¤è¯
â”‚   â”‚       â”œâ”€â”€ system_three.rs  # ä¸‰çº§æ²»ç†ä¸­å¿ƒè®¤è¯
â”‚   â”‚       â”œâ”€â”€ system_drs.rs    # DRS ç³»ç»Ÿè®¤è¯
â”‚   â”‚       â””â”€â”€ åè®®/            # åè®®æ–‡ä»¶(é¢„ç•™)
â”‚   â”œâ”€â”€ capture/                 # ç½‘ç»œæŠ“åŒ…æ¨¡å— (ç°æœ‰å®ç°)
â”‚   â”‚   â”œâ”€â”€ mod.rs               # æŠ“åŒ…æ¨¡å—å…¥å£
â”‚   â”‚   â””â”€â”€ capture.rs           # æŠ“åŒ…å®ç°
â”‚   â”œâ”€â”€ utils/                   # å·¥å…·åº“
â”‚   â”‚   â”œâ”€â”€ mod.rs               # å·¥å…·æ¨¡å—å¯¼å‡º
â”‚   â”‚   â”œâ”€â”€ crypto.rs            # åŠ å¯†å·¥å…·
â”‚   â”‚   â”œâ”€â”€ parser.rs            # è§£æå·¥å…·
â”‚   â”‚   â”œâ”€â”€ time.rs              # æ—¶é—´å·¥å…·
â”‚   â”‚   â””â”€â”€ validation.rs        # éªŒè¯å·¥å…·
â”‚   â”œâ”€â”€ tests/                   # æµ‹è¯•ç›®å½•
â”‚   â”‚   â”œâ”€â”€ integration/         # é›†æˆæµ‹è¯•
â”‚   â”‚   â””â”€â”€ unit/                # å•å…ƒæµ‹è¯•
â”‚   â””â”€â”€ cmd.rs                   # æ—§ç‰ˆå‘½ä»¤å¤„ç†(å¾…è¿ç§»)
â””â”€â”€ target/                      # ç¼–è¯‘è¾“å‡ºç›®å½•
```

### æ¨¡å—æ¶æ„è¯¦è§£

#### 1. åº”ç”¨å…¥å£ (lib.rs)
```rust
// åº”ç”¨æ ¸å¿ƒæ¨¡å—
pub mod app;
pub mod api;
pub mod domain;
pub mod infrastructure;
pub mod utils;

// ä¿ç•™åŸæœ‰æ¨¡å—ä»¥ä¾¿æ¸è¿›å¼è¿ç§»
mod capture;
mod auth;
mod cmd;

use log::{error, info, warn};
use app::AppSetup;
use tauri::Manager;

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    // åˆå§‹åŒ–ç°ä»£åŒ–æ—¥å¿—ç³»ç»Ÿ
    if let Err(e) = app::init_log_system() {
        eprintln!("âŒ åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿå¤±è´¥: {}", e);
    } else {
        println!("âœ… ç°ä»£åŒ–æ—¥å¿—ç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸ");
    }
    
    info!("ğŸš€ å¯åŠ¨æ•°å­—é‡åº†ä¸šåŠ¡æ•°æ®å·¡æŸ¥è‡ªåŠ¨åŒ–ç³»ç»Ÿ v{}", env!("CARGO_PKG_VERSION"));
    
    tauri::Builder::default()
        .plugin(tauri_plugin_shell::init())
        .plugin(tauri_plugin_prevent_default::init())
        .invoke_handler(tauri::generate_handler![
            // æ–°çš„APIæ¥å£
            api::get_capture_status,
            api::init_capture,
            api::stop_capture,
            api::get_network_devices,
            api::get_all_token_status,
            api::get_system_token,
            // ç°ä»£åŒ–æ—¥å¿—ç³»ç»Ÿå‘½ä»¤
            api::get_recent_logs,
            api::subscribe_log_stream,
            api::unsubscribe_log_stream,
            api::clear_logs,
            api::get_log_stats,
        ])
        .setup(|app| {
            // ä½¿ç”¨æ–°çš„åˆå§‹åŒ–æµç¨‹
            let rt = tokio::runtime::Runtime::new().expect("Failed to create Tokio runtime");
            
            match rt.block_on(async {
                // åˆå§‹åŒ–åº”ç”¨çŠ¶æ€
                let app_state = AppSetup::initialize().await?;
                
                // å°†åº”ç”¨çŠ¶æ€å­˜å‚¨åˆ°Tauriçš„çŠ¶æ€ç®¡ç†ä¸­
                app.manage(app_state);
                
                // åˆå§‹åŒ–æ—§çš„ç³»ç»Ÿä»¥ä¿æŒå…¼å®¹æ€§
                init_legacy_systems(app.handle().clone()).await?;
                
                Ok::<(), app::AppError>(())
            }) {
                Ok(_) => info!("âœ… åº”ç”¨ç¨‹åºåˆå§‹åŒ–å®Œæˆ"),
                Err(e) => {
                    error!("âŒ åº”ç”¨ç¨‹åºåˆå§‹åŒ–å¤±è´¥: {}", e);
                    return Err(Box::new(e));
                }
            }
            
            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

#### 2. APIå±‚æ¶æ„ (api/)
```rust
// api/mod.rs - APIç»Ÿä¸€å¯¼å‡º
pub mod capture;
pub mod auth;
pub mod system;
pub mod window;
pub mod logging;

// é‡æ–°å¯¼å‡ºæ‰€æœ‰APIå‘½ä»¤
pub use capture::*;
pub use auth::*;
pub use system::*;
pub use window::*;
pub use logging::*;

// api/logging.rs - æ—¥å¿—APIå®ç°
use tauri::{State, Window};
use crate::app::logging::{get_log_system, LogFilters, LogEntry};

#[tauri::command]
pub async fn get_recent_logs(
    limit: Option<usize>,
    filters: Option<LogFilters>,
    _state: State<'_, crate::app::AppState>
) -> Result<Vec<LogEntry>, String> {
    log::info!("ğŸ“‹ è·å–æœ€è¿‘æ—¥å¿—ï¼Œé™åˆ¶: {:?}", limit);
    
    if let Some(log_system) = get_log_system() {
        let logs = log_system.get_recent_logs(limit.unwrap_or(1000), filters);
        Ok(logs)
    } else {
        Err("æ—¥å¿—ç³»ç»Ÿæœªåˆå§‹åŒ–".to_string())
    }
}

#[tauri::command]
pub async fn subscribe_log_stream(
    window: Window,
    filters: Option<LogFilters>,
    _state: State<'_, crate::app::AppState>
) -> Result<(), String> {
    if let Some(log_system) = get_log_system() {
        let filters = filters.unwrap_or_default();
        log_system.add_subscriber(window, filters);
        Ok(())
    } else {
        Err("æ—¥å¿—ç³»ç»Ÿæœªåˆå§‹åŒ–".to_string())
    }
}

// api/capture.rs - æ•è·APIå®ç°
#[tauri::command]
pub async fn get_capture_status() -> Result<CaptureStatus, String> {
    crate::capture::get_capture_status().map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn init_capture(device_name: String) -> Result<(), String> {
    crate::capture::start_capture(&device_name).map_err(|e| e.to_string())
}
```

#### 3. åº”ç”¨å±‚æ¶æ„ (app/)
```rust
// app/mod.rs - åº”ç”¨å±‚æ¨¡å—å¯¼å‡º
pub mod config;
pub mod error;
pub mod state;
pub mod setup;
pub mod logging;

// é‡æ–°å¯¼å‡ºé‡è¦çš„ç±»å‹
pub use config::AppConfig;
pub use error::{AppError, AppResult, NetworkError, AuthError};
pub use state::AppState;
pub use setup::AppSetup;
pub use logging::{init_log_system, get_log_system, LogEntry, LogLevel, LogFilters};

// app/logging.rs - ç°ä»£åŒ–æ—¥å¿—ç³»ç»Ÿæ ¸å¿ƒ
use std::collections::HashMap;
use std::sync::{Arc, RwLock, atomic::{AtomicU64, Ordering}};
use serde::{Serialize, Deserialize};
use tokio::sync::broadcast;
use chrono::Utc;
use once_cell::sync::OnceCell;
use tauri::Emitter;

/// ç°ä»£åŒ–æ—¥å¿—ç³»ç»Ÿ
pub struct ModernLogSystem {
    /// ç¯å½¢ç¼“å†²åŒº
    pub buffer: Arc<RwLock<CircularBuffer<LogEntry>>>,
    /// å¹¿æ’­å‘é€å™¨
    broadcaster: broadcast::Sender<LogEntry>,
    /// IDç”Ÿæˆå™¨
    id_counter: AtomicU64,
    /// è®¢é˜…è€…åˆ—è¡¨
    subscribers: Arc<RwLock<Vec<LogSubscriber>>>,
}

impl ModernLogSystem {
    pub fn new(buffer_capacity: usize) -> Self {
        let (sender, _) = broadcast::channel(1000);
        
        Self {
            buffer: Arc::new(RwLock::new(CircularBuffer::new(buffer_capacity))),
            broadcaster: sender,
            id_counter: AtomicU64::new(1),
            subscribers: Arc::new(RwLock::new(Vec::new())),
        }
    }
    
    /// æ·»åŠ æ—¥å¿—æ¡ç›®
    pub fn add_log(&self, entry: LogEntry) {
        // å­˜å‚¨åˆ°ç¯å½¢ç¼“å†²åŒº
        {
            let mut buffer = self.buffer.write().unwrap();
            buffer.push(entry.clone());
        }
        
        // å¹¿æ’­ç»™è®¢é˜…è€…
        let _ = self.broadcaster.send(entry.clone());
        
        // æ¨é€ç»™å‰ç«¯è®¢é˜…è€…
        self.notify_subscribers(&entry);
    }
}

// app/setup.rs - åº”ç”¨åˆå§‹åŒ–
pub struct AppSetup;

impl AppSetup {
    pub async fn initialize() -> Result<AppState, AppError> {
        // åˆå§‹åŒ–åº”ç”¨çŠ¶æ€
        let state = AppState::new().await?;
        
        // æ‰§è¡Œå…¶ä»–åˆå§‹åŒ–ä»»åŠ¡
        Self::setup_logging().await?;
        Self::setup_configurations().await?;
        
        Ok(state)
    }
    
    async fn setup_logging() -> Result<(), AppError> {
        // åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
        init_log_system().map_err(|e| AppError::InitializationError(e.to_string()))?;
        Ok(())
    }
    
    async fn setup_configurations() -> Result<(), AppError> {
        // åŠ è½½é…ç½®æ–‡ä»¶
        // éªŒè¯ç³»ç»Ÿæƒé™
        // åˆå§‹åŒ–ç½‘ç»œç»„ä»¶
        Ok(())
    }
}
```

#### 4. ç½‘ç»œæŠ“åŒ…æ¨¡å— (capture/)
```rust
// capture.rs - æŠ“åŒ…å®ç°
pub struct CaptureStatus {
    pub is_running: bool,
    pub packets_captured: u64,
    pub bytes_captured: u64,
    pub start_time: Option<u64>,
    pub device_name: Option<String>,
}

pub async fn start_capture(device_name: &str) -> Result<()> {
    // 1. åˆå§‹åŒ–ç½‘ç»œè®¾å¤‡
    let device = Device::lookup().unwrap()
        .find(|d| d.name == device_name)
        .ok_or_else(|| anyhow!("è®¾å¤‡ä¸å­˜åœ¨"))?;
    
    // 2. åˆ›å»ºæŠ“åŒ…å®ä¾‹
    let mut cap = Capture::from_device(device)?
        .promisc(true)
        .snaplen(65535)
        .timeout(1000)
        .open()?;
    
    // 3. è®¾ç½®è¿‡æ»¤å™¨
    cap.filter("tcp port 80 or tcp port 8080 or tcp port 443", true)?;
    
    // 4. å¼€å§‹æŠ“åŒ…å¾ªç¯
    while let Ok(packet) = cap.next_packet() {
        process_packet(packet).await?;
    }
    
    Ok(())
}

async fn process_packet(packet: Packet) -> Result<()> {
    // 1. è§£æä»¥å¤ªç½‘å¸§
    let ethernet = EthernetSlice::from_slice(&packet.data)?;
    
    // 2. è§£æIPå±‚
    let ip = match ethernet.payload() {
        EtherPayload::Ipv4(header, payload) => (header, payload),
        _ => return Ok(()),
    };
    
    // 3. è§£æTCPå±‚
    let tcp = TcpSlice::from_slice(ip.1)?;
    
    // 4. è§£æHTTPå±‚
    if let Some(http_packet) = parse_http_packet(&tcp.payload()) {
        send_http_packet(http_packet).await?;
        auth::process_http_packet(&http_packet).await?;
    }
    
    Ok(())
}
```

## ğŸ”§ é…ç½®æ–‡ä»¶ç»“æ„

### 1. Tauri é…ç½® (tauri.conf.json)
```json
{
  "productName": "æ•°å­—é‡åº†ä¸šåŠ¡æ•°æ®å·¡æŸ¥è‡ªåŠ¨åŒ–ç³»ç»Ÿ",
  "version": "0.7.0",
  "identifier": "com.sumi.big-data-rpa-v4",
  "app": {
    "windows": [
      {
        "title": "æ•°å­—é‡åº†ä¸šåŠ¡æ•°æ®å·¡æŸ¥è‡ªåŠ¨åŒ–ç³»ç»Ÿ",
        "width": 1200,
        "height": 800,
        "minWidth": 800,
        "minHeight": 600
      }
    ]
  },
  "permissions": [
    "core:default",
    "shell:allow-open",
    "log:default"
  ]
}
```

### 2. å‰ç«¯é…ç½®æ–‡ä»¶
```typescript
// vite.config.ts - Vite é…ç½®
export default defineConfig({
  plugins: [
    vue(),
    AutoImport({
      imports: ['vue', 'vue-router', 'pinia'],
      dts: true
    }),
    Components({
      dts: true
    })
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  }
})

// tailwind.config.cjs - TailwindCSS é…ç½®
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{vue,js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: '#2563eb',
        secondary: '#64748b'
      }
    }
  }
}
```

### 3. TypeScript é…ç½®
```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

## ğŸ“¦ ä¾èµ–ç®¡ç†

### å‰ç«¯ä¾èµ– (package.json)
```json
{
  "dependencies": {
    "@tauri-apps/api": "^2.6.0",
    "pinia": "^3.0.3",
    "vue": "^3.5.17",
    "vue-router": "^4.5.1",
    "pako": "^2.1.0"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^6.0.0",
    "typescript": "^5.8.3",
    "vite": "^7.0.0",
    "tailwindcss": "^4.1.10"
  }
}
```

### åç«¯ä¾èµ– (Cargo.toml)
```toml
[dependencies]
tauri = { version = "2", features = ["devtools"] }
serde = { version = "1", features = ["derive"] }
tokio = { version = "1.40", features = ["full"] }
pcap = "2.2.0"
etherparse = "0.18.0"
anyhow = "1.0.98"
log = "0.4.27"
chrono = { version = "0.4", features = ["serde"] }
dashmap = "6.1"
```

## ğŸ”„ æ•°æ®æµæ¶æ„

### å‰ç«¯æ•°æ®æµ
```
ç”¨æˆ·æ“ä½œ â†’ ç»„ä»¶äº‹ä»¶ â†’ Store Action â†’ Tauri Command â†’ Rust å¤„ç†
    â†‘                                                    â†“
UI æ›´æ–° â† Store State â† Channel Event â† Rust åå°ä»»åŠ¡
```

### åç«¯æ•°æ®æµ
```
ç½‘ç»œæ•°æ®åŒ… â†’ åè®®è§£æ â†’ HTTP è¯†åˆ« â†’ Token æå– â†’ çŠ¶æ€æ›´æ–° â†’ å‰ç«¯æ¨é€
```

## ğŸ§ª æµ‹è¯•ç»“æ„

### æµ‹è¯•ç›®å½•
```
tests/
â”œâ”€â”€ setup/                       # æµ‹è¯•ç¯å¢ƒè®¾ç½®
â”‚   â”œâ”€â”€ install-pinia.ts        # Pinia æµ‹è¯•é…ç½®
â”‚   â””â”€â”€ testglobals.ts          # æµ‹è¯•å…¨å±€é…ç½®
â””â”€â”€ unit/                       # å•å…ƒæµ‹è¯•
    â””â”€â”€ example.test.ts         # ç¤ºä¾‹æµ‹è¯•
```

### æµ‹è¯•é…ç½®
```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    environment: 'jsdom',
    setupFiles: ['./tests/setup/install-pinia.ts'],
    globals: true
  }
})
```

è¿™ä¸ªä»£ç ç»“æ„å±•ç°äº†ä¸€ä¸ªç°ä»£åŒ–çš„æ¡Œé¢åº”ç”¨æ¶æ„ï¼Œå‰åç«¯åˆ†ç¦»ï¼Œæ¨¡å—åŒ–æ¸…æ™°ï¼Œä¾¿äºç»´æŠ¤å’Œæ‰©å±•ã€‚