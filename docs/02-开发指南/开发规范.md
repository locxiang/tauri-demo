# å¼€å‘è§„èŒƒ

## ğŸ“‹ ä»£ç é£æ ¼è§„èŒƒ

### 1. Rust ä»£ç è§„èŒƒ

#### å‘½åçº¦å®š
```rust
// æ¨¡å—åï¼šå°å†™å­—æ¯ + ä¸‹åˆ’çº¿
mod network_capture;
mod auth_system;

// ç»“æ„ä½“ï¼šå¸•æ–¯å¡å‘½åæ³•
struct HttpPacket {
    id: u64,
    timestamp: u64,
}

// å‡½æ•°åï¼šå°å†™å­—æ¯ + ä¸‹åˆ’çº¿
fn process_http_packet(packet: &HttpPacket) -> Result<()> {
    // å®ç°
}

// å¸¸é‡ï¼šå…¨å¤§å†™å­—æ¯ + ä¸‹åˆ’çº¿
const MAX_PACKET_SIZE: usize = 65535;
const DEFAULT_TIMEOUT: u64 = 1000;

// æšä¸¾ï¼šå¸•æ–¯å¡å‘½åæ³•
enum TokenState {
    Active,
    Expired,
    Waiting,
    Failed,
}
```

#### é”™è¯¯å¤„ç†
```rust
// ä¼˜å…ˆä½¿ç”¨ Result ç±»å‹
fn init_capture(device_name: &str) -> Result<()> {
    // ä½¿ç”¨ ? æ“ä½œç¬¦ä¼ æ’­é”™è¯¯
    let device = find_device(device_name)?;
    let capture = create_capture(device)?;
    
    Ok(())
}

// ä½¿ç”¨ anyhow è¿›è¡Œé”™è¯¯å¤„ç†
use anyhow::{Result, anyhow};

fn validate_token(token: &str) -> Result<bool> {
    if token.is_empty() {
        return Err(anyhow!("Tokenä¸èƒ½ä¸ºç©º"));
    }
    
    Ok(token.len() > 10)
}
```

#### æ–‡æ¡£æ³¨é‡Š
```rust
/// å¤„ç†HTTPæ•°æ®åŒ…çš„è®¤è¯ä¿¡æ¯æå–
/// 
/// # Arguments
/// 
/// * `packet` - HTTPæ•°æ®åŒ…å¯¹è±¡
/// 
/// # Returns
/// 
/// * `Result<Option<TokenInfo>>` - æå–çš„Tokenä¿¡æ¯ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°åˆ™è¿”å›None
/// 
/// # Examples
/// 
/// ```
/// let token_info = process_http_request(&packet)?;
/// if let Some(token) = token_info {
///     println!("æ‰¾åˆ°Token: {}", token.token);
/// }
/// ```
pub fn process_http_request(packet: &HttpPacket) -> Result<Option<TokenInfo>> {
    // å®ç°
}
```

#### å¼‚æ­¥ç¼–ç¨‹
```rust
// ä½¿ç”¨ async/await
async fn fetch_system_data(url: &str) -> Result<String> {
    let response = reqwest::get(url).await?;
    let text = response.text().await?;
    Ok(text)
}

// å¹¶å‘å¤„ç†
async fn process_multiple_systems() -> Result<()> {
    let futures = vec![
        fetch_system_data("http://system1.com/api"),
        fetch_system_data("http://system2.com/api"),
        fetch_system_data("http://system3.com/api"),
    ];
    
    let results = tokio::try_join!(futures[0], futures[1], futures[2])?;
    
    Ok(())
}
```

### 2. TypeScript/Vue ä»£ç è§„èŒƒ

#### ç»„ä»¶å‘½å
```typescript
// ç»„ä»¶åï¼šå¸•æ–¯å¡å‘½åæ³•
export default defineComponent({
  name: 'NetworkDeviceComponent',
  // ...
})

// æ–‡ä»¶åï¼šå°å†™å­—æ¯ + è¿å­—ç¬¦
// NetworkDeviceComponent.vue
// packet-filter.component.vue
```

#### ç±»å‹å®šä¹‰
```typescript
// æ¥å£å®šä¹‰ï¼šå¸•æ–¯å¡å‘½åæ³•
interface TokenStatus {
  system_id: string;
  system_name: string;
  has_token: boolean;
  token_acquired_at?: number;
  token_expires_at?: number;
  status: TokenState;
}

// ç±»å‹åˆ«å
type NetworkDevice = {
  name: string;
  description: string;
  is_loopback: boolean;
  addresses: string[];
};

// æšä¸¾
enum TokenState {
  Active = 'active',
  Expired = 'expired',
  Waiting = 'waiting',
  Failed = 'failed'
}
```

#### Vue ç»„ä»¶ç»“æ„
```vue
<template>
  <!-- æ¨¡æ¿å†…å®¹ -->
  <div class="component-container">
    <!-- ä½¿ç”¨è¯­ä¹‰åŒ–çš„ç±»å -->
    <header class="component-header">
      <h2 class="component-title">{{ title }}</h2>
    </header>
    
    <main class="component-content">
      <!-- ä¸»è¦å†…å®¹ -->
    </main>
  </div>
</template>

<script setup lang="ts">
// 1. å¯¼å…¥ä¾èµ–
import { ref, computed, onMounted } from 'vue'
import { useRouter } from 'vue-router'
import { useAppStore } from '@/stores'

// 2. å®šä¹‰æ¥å£/ç±»å‹
interface ComponentProps {
  title: string;
  data: any[];
}

// 3. å®šä¹‰ Props
const props = withDefaults(defineProps<ComponentProps>(), {
  title: 'é»˜è®¤æ ‡é¢˜',
  data: () => []
})

// 4. å®šä¹‰ Emits
const emit = defineEmits<{
  update: [value: string];
  change: [id: number];
}>()

// 5. å“åº”å¼æ•°æ®
const loading = ref(false)
const items = ref<any[]>([])

// 6. è®¡ç®—å±æ€§
const filteredItems = computed(() => {
  return items.value.filter(item => item.active)
})

// 7. æ–¹æ³•
const handleUpdate = (value: string) => {
  emit('update', value)
}

// 8. ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  // åˆå§‹åŒ–é€»è¾‘
})
</script>

<style scoped>
/* ä½¿ç”¨ scoped æ ·å¼ */
.component-container {
  @apply p-4 bg-white rounded-lg shadow;
}

.component-header {
  @apply mb-4 border-b pb-2;
}

.component-title {
  @apply text-xl font-semibold text-gray-800;
}
</style>
```

#### Store è§„èŒƒ
```typescript
// store æ–‡ä»¶å‘½åï¼šå°é©¼å³° + Store åç¼€
// authStore.ts, proxyStore.ts

export const useAuthStore = defineStore('auth', {
  state: () => ({
    tokenStatus: [] as TokenStatus[],
    tokenEvents: [] as TokenEvent[],
    loading: false,
    error: null as string | null
  }),
  
  getters: {
    // ä½¿ç”¨ç®­å¤´å‡½æ•°å’Œç±»å‹æ ‡æ³¨
    activeTokens: (state): TokenStatus[] => {
      return state.tokenStatus.filter(token => token.status === TokenState.Active)
    },
    
    // å¤æ‚è®¡ç®—å±æ€§
    tokenStatistics: (state): TokenStatistics => {
      const active = state.tokenStatus.filter(t => t.status === TokenState.Active).length
      const expired = state.tokenStatus.filter(t => t.status === TokenState.Expired).length
      const waiting = state.tokenStatus.filter(t => t.status === TokenState.Waiting).length
      const failed = state.tokenStatus.filter(t => t.status === TokenState.Failed).length
      
      return { active, expired, waiting, failed }
    }
  },
  
  actions: {
    // å¼‚æ­¥æ–¹æ³•ä½¿ç”¨ async/await
    async initialize() {
      this.loading = true
      this.error = null
      
      try {
        await this.setupTokenEventChannel()
        await this.refreshTokenStatus()
      } catch (error) {
        this.error = error instanceof Error ? error.message : 'åˆå§‹åŒ–å¤±è´¥'
        throw error
      } finally {
        this.loading = false
      }
    },
    
    // åŒæ­¥æ–¹æ³•
    updateTokenStatus(status: TokenStatus[]) {
      this.tokenStatus = status
    }
  }
})
```

## ğŸ—‚ï¸ é¡¹ç›®ç»„ç»‡è§„èŒƒ

### ç›®å½•ç»“æ„
```
src/
â”œâ”€â”€ components/          # é€šç”¨ç»„ä»¶
â”‚   â”œâ”€â”€ base/           # åŸºç¡€ç»„ä»¶
â”‚   â”œâ”€â”€ business/       # ä¸šåŠ¡ç»„ä»¶
â”‚   â””â”€â”€ layout/         # å¸ƒå±€ç»„ä»¶
â”œâ”€â”€ views/              # é¡µé¢ç»„ä»¶
â”‚   â”œâ”€â”€ Dashboard/      # æ¯ä¸ªé¡µé¢ä¸€ä¸ªæ–‡ä»¶å¤¹
â”‚   â”‚   â”œâ”€â”€ index.vue   # ä¸»é¡µé¢æ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ components/ # é¡µé¢ä¸“ç”¨ç»„ä»¶
â”‚   â”‚   â””â”€â”€ types.ts    # é¡µé¢ç±»å‹å®šä¹‰
â”œâ”€â”€ stores/             # çŠ¶æ€ç®¡ç†
â”œâ”€â”€ utils/              # å·¥å…·å‡½æ•°
â”œâ”€â”€ types/              # ç±»å‹å®šä¹‰
â”œâ”€â”€ constants/          # å¸¸é‡å®šä¹‰
â””â”€â”€ assets/             # é™æ€èµ„æº
```

### æ–‡ä»¶å‘½åè§„èŒƒ
```
# Vue ç»„ä»¶
PascalCase.vue          # ç»„ä»¶æ–‡ä»¶
kebab-case.component.vue # å¤æ‚ç»„ä»¶

# TypeScript æ–‡ä»¶
camelCase.ts           # å·¥å…·å‡½æ•°
PascalCase.ts          # ç±»å®šä¹‰
kebab-case.types.ts    # ç±»å‹å®šä¹‰

# æ ·å¼æ–‡ä»¶
kebab-case.css
component-name.module.css
```

## ğŸ”§ Git æäº¤è§„èŒƒ

### æäº¤æ¶ˆæ¯æ ¼å¼
```
<type>(<scope>): <subject>

<body>

<footer>
```

### æäº¤ç±»å‹
- **feat**: æ–°åŠŸèƒ½
- **fix**: ä¿®å¤ bug
- **docs**: æ–‡æ¡£ä¿®æ”¹
- **style**: ä»£ç æ ¼å¼ä¿®æ”¹
- **refactor**: ä»£ç é‡æ„
- **test**: æµ‹è¯•ç›¸å…³
- **chore**: æ„å»ºè¿‡ç¨‹æˆ–è¾…åŠ©å·¥å…·çš„å˜åŠ¨

### æäº¤ç¤ºä¾‹
```bash
# æ–°åŠŸèƒ½
git commit -m "feat(auth): æ·»åŠ Tokenè‡ªåŠ¨åˆ·æ–°åŠŸèƒ½"

# ä¿®å¤bug
git commit -m "fix(capture): ä¿®å¤ç½‘ç»œè®¾å¤‡æ£€æµ‹å¤±è´¥é—®é¢˜"

# æ–‡æ¡£æ›´æ–°
git commit -m "docs(readme): æ›´æ–°ç¯å¢ƒæ­å»ºè¯´æ˜"

# ä»£ç é‡æ„
git commit -m "refactor(store): é‡æ„è®¤è¯çŠ¶æ€ç®¡ç†é€»è¾‘"
```

### åˆ†æ”¯å‘½åè§„èŒƒ
```bash
# åŠŸèƒ½åˆ†æ”¯
feature/token-auto-refresh
feature/network-device-selection

# ä¿®å¤åˆ†æ”¯
fix/capture-permission-error
fix/ui-display-issue

# å‘å¸ƒåˆ†æ”¯
release/v0.8.0

# çƒ­ä¿®å¤åˆ†æ”¯
hotfix/critical-security-fix
```

## ğŸ“ æ³¨é‡Šè§„èŒƒ

### æ–‡ä»¶å¤´æ³¨é‡Š
```typescript
/**
 * è®¤è¯çŠ¶æ€ç®¡ç† Store
 * 
 * è´Ÿè´£ç®¡ç†å¤šä¸ªä¸šåŠ¡ç³»ç»Ÿçš„Tokenè®¤è¯çŠ¶æ€ï¼ŒåŒ…æ‹¬ï¼š
 * - TokençŠ¶æ€çš„å®æ—¶æ›´æ–°
 * - Tokenè¿‡æœŸæ£€æµ‹å’Œé¢„è­¦
 * - Tokenäº‹ä»¶çš„å†å²è®°å½•
 * 
 * @author å¼€å‘å›¢é˜Ÿ
 * @version 1.0.0
 * @since 2024-12-01
 */
```

### å‡½æ•°æ³¨é‡Š
```typescript
/**
 * æ ¼å¼åŒ–å‰©ä½™æ—¶é—´æ˜¾ç¤º
 * 
 * @param expiresAt - Tokenè¿‡æœŸæ—¶é—´æˆ³
 * @returns æ ¼å¼åŒ–åçš„æ—¶é—´å­—ç¬¦ä¸²ï¼Œå¦‚ "2å°æ—¶30åˆ†é’Ÿ" æˆ– "å·²è¿‡æœŸ"
 */
function formatRemainingTime(expiresAt: number): string {
  // å®ç°
}
```

### å¤æ‚é€»è¾‘æ³¨é‡Š
```typescript
// è®¡ç®—Tokenå‰©ä½™æ—¶é—´
// 1. è·å–å½“å‰æ—¶é—´æˆ³
const now = Date.now()

// 2. è®¡ç®—æ—¶é—´å·®ï¼ˆæ¯«ç§’ï¼‰
const diff = expiresAt - now

// 3. åˆ¤æ–­æ˜¯å¦è¿‡æœŸ
if (diff <= 0) {
  return 'å·²è¿‡æœŸ'
}

// 4. æ ¼å¼åŒ–æ˜¾ç¤º
const hours = Math.floor(diff / (1000 * 60 * 60))
const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60))
```

## ğŸ§ª æµ‹è¯•è§„èŒƒ

### å•å…ƒæµ‹è¯•
```typescript
// æµ‹è¯•æ–‡ä»¶å‘½åï¼š*.test.ts
// utils.test.ts, store.test.ts

import { describe, test, expect } from 'vitest'
import { formatRemainingTime } from '@/utils/time'

describe('æ—¶é—´å·¥å…·å‡½æ•°', () => {
  test('åº”è¯¥æ­£ç¡®æ ¼å¼åŒ–å‰©ä½™æ—¶é—´', () => {
    const now = Date.now()
    const twoHoursLater = now + 2 * 60 * 60 * 1000
    
    const result = formatRemainingTime(twoHoursLater)
    
    expect(result).toBe('2å°æ—¶0åˆ†é’Ÿ')
  })
  
  test('åº”è¯¥å¤„ç†è¿‡æœŸæ—¶é—´', () => {
    const now = Date.now()
    const oneHourAgo = now - 1 * 60 * 60 * 1000
    
    const result = formatRemainingTime(oneHourAgo)
    
    expect(result).toBe('å·²è¿‡æœŸ')
  })
})
```

### ç»„ä»¶æµ‹è¯•
```typescript
import { mount } from '@vue/test-utils'
import { describe, test, expect } from 'vitest'
import TokenStatusCard from '@/components/TokenStatusCard.vue'

describe('TokenStatusCard', () => {
  test('åº”è¯¥æ­£ç¡®æ˜¾ç¤ºTokençŠ¶æ€', async () => {
    const wrapper = mount(TokenStatusCard, {
      props: {
        tokenStatus: {
          system_id: 'test_system',
          system_name: 'æµ‹è¯•ç³»ç»Ÿ',
          has_token: true,
          status: 'active'
        }
      }
    })
    
    expect(wrapper.text()).toContain('æµ‹è¯•ç³»ç»Ÿ')
    expect(wrapper.text()).toContain('æ­£å¸¸')
  })
})
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–è§„èŒƒ

### å‰ç«¯æ€§èƒ½
```typescript
// 1. ä½¿ç”¨ computed è€Œä¸æ˜¯ methods
const filteredData = computed(() => {
  return data.value.filter(item => item.active)
})

// 2. é¿å…åœ¨æ¨¡æ¿ä¸­ä½¿ç”¨å¤æ‚è®¡ç®—
// âŒ é”™è¯¯
<template>
  <div>{{ data.filter(item => item.active).length }}</div>
</template>

// âœ… æ­£ç¡®
<template>
  <div>{{ activeCount }}</div>
</template>

// 3. ä½¿ç”¨ v-memo ä¼˜åŒ–åˆ—è¡¨æ¸²æŸ“
<template>
  <div v-for="item in list" :key="item.id" v-memo="[item.id, item.status]">
    {{ item.name }}
  </div>
</template>
```

### åç«¯æ€§èƒ½
```rust
// 1. ä½¿ç”¨å¼•ç”¨è€Œä¸æ˜¯å€¼ä¼ é€’
fn process_packet(packet: &HttpPacket) -> Result<()> {
    // é¿å…ä¸å¿…è¦çš„å…‹éš†
}

// 2. ä½¿ç”¨ Arc å’Œ Mutex è¿›è¡Œå¹¶å‘æ§åˆ¶
use std::sync::{Arc, Mutex};
use once_cell::sync::OnceCell;

static SHARED_STATE: OnceCell<Arc<Mutex<State>>> = OnceCell::new();

// 3. ä½¿ç”¨ try_lock é¿å…é˜»å¡
if let Ok(guard) = state.try_lock() {
    // å¤„ç†é€»è¾‘
} else {
    // å¤„ç†é”ç¹å¿™çš„æƒ…å†µ
}
```

## ğŸ”’ å®‰å…¨è§„èŒƒ

### æ•æ„Ÿä¿¡æ¯å¤„ç†
```typescript
// âŒ é”™è¯¯ï¼šä¸è¦åœ¨æ—¥å¿—ä¸­è¾“å‡ºå®Œæ•´Token
console.log('Token:', token)

// âœ… æ­£ç¡®ï¼šåªè¾“å‡ºTokené•¿åº¦æˆ–å‰å‡ ä½
console.log('Tokené•¿åº¦:', token.length)
console.log('Tokenå‰ç¼€:', token.substring(0, 8) + '...')
```

### è¾“å…¥éªŒè¯
```typescript
// éªŒè¯ç”¨æˆ·è¾“å…¥
function validateInput(input: string): boolean {
  // æ£€æŸ¥é•¿åº¦
  if (input.length > 1000) {
    return false
  }
  
  // æ£€æŸ¥ç‰¹æ®Šå­—ç¬¦
  const dangerousChars = /<script|javascript:|data:/i
  if (dangerousChars.test(input)) {
    return false
  }
  
  return true
}
```

## ğŸ“Š ä»£ç è´¨é‡æ£€æŸ¥

### ESLint é…ç½®
```json
{
  "extends": [
    "@vue/eslint-config-typescript",
    "@vue/eslint-config-prettier"
  ],
  "rules": {
    "no-console": "warn",
    "no-debugger": "error",
    "@typescript-eslint/no-unused-vars": "error",
    "vue/no-unused-components": "error"
  }
}
```

### ä»£ç å®¡æŸ¥æ¸…å•
- [ ] ä»£ç é£æ ¼æ˜¯å¦ç¬¦åˆè§„èŒƒ
- [ ] æ˜¯å¦æœ‰é€‚å½“çš„é”™è¯¯å¤„ç†
- [ ] æ˜¯å¦æœ‰å¿…è¦çš„æ³¨é‡Š
- [ ] æ˜¯å¦æœ‰å®‰å…¨éšæ‚£
- [ ] æ€§èƒ½æ˜¯å¦åˆç†
- [ ] æµ‹è¯•è¦†ç›–ç‡æ˜¯å¦è¶³å¤Ÿ
- [ ] æäº¤ä¿¡æ¯æ˜¯å¦è§„èŒƒ

## ğŸ“š æ–‡æ¡£è§„èŒƒ

### API æ–‡æ¡£
```typescript
/**
 * è·å–æ‰€æœ‰TokençŠ¶æ€
 * 
 * @returns Promise<TokenStatus[]> TokençŠ¶æ€åˆ—è¡¨
 * @throws Error å½“è®¤è¯ç³»ç»Ÿæœªåˆå§‹åŒ–æ—¶æŠ›å‡ºå¼‚å¸¸
 * 
 * @example
 * ```typescript
 * const tokens = await getAllTokenStatus()
 * console.log('æ´»è·ƒTokenæ•°é‡:', tokens.filter(t => t.status === 'active').length)
 * ```
 */
async function getAllTokenStatus(): Promise<TokenStatus[]> {
  // å®ç°
}
```

### README æ–‡æ¡£
```markdown
# ç»„ä»¶åç§°

## åŠŸèƒ½æè¿°
ç®€è¦æè¿°ç»„ä»¶çš„åŠŸèƒ½å’Œç”¨é€”

## ä½¿ç”¨æ–¹æ³•
\`\`\`typescript
import { ComponentName } from '@/components'

// ä½¿ç”¨ç¤ºä¾‹
\`\`\`

## API
| å±æ€§ | ç±»å‹ | é»˜è®¤å€¼ | è¯´æ˜ |
|------|------|--------|------|
| prop1 | string | '' | å±æ€§è¯´æ˜ |

## æ³¨æ„äº‹é¡¹
- ä½¿ç”¨æ—¶éœ€è¦æ³¨æ„çš„äº‹é¡¹
- å·²çŸ¥é—®é¢˜å’Œé™åˆ¶
```

éµå¾ªè¿™äº›å¼€å‘è§„èŒƒï¼Œå¯ä»¥ç¡®ä¿ä»£ç è´¨é‡ã€æé«˜å¼€å‘æ•ˆç‡ã€å‡å°‘bugï¼Œå¹¶æå‡å›¢é˜Ÿåä½œæ•ˆç‡ã€‚