# 开发规范

## 📋 代码风格规范

### 1. Rust 代码规范

#### 命名约定
```rust
// 模块名：小写字母 + 下划线
mod network_capture;
mod auth_system;

// 结构体：帕斯卡命名法
struct HttpPacket {
    id: u64,
    timestamp: u64,
}

// 函数名：小写字母 + 下划线
fn process_http_packet(packet: &HttpPacket) -> Result<()> {
    // 实现
}

// 常量：全大写字母 + 下划线
const MAX_PACKET_SIZE: usize = 65535;
const DEFAULT_TIMEOUT: u64 = 1000;

// 枚举：帕斯卡命名法
enum TokenState {
    Active,
    Expired,
    Waiting,
    Failed,
}
```

#### 错误处理
```rust
// 优先使用 Result 类型
fn init_capture(device_name: &str) -> Result<()> {
    // 使用 ? 操作符传播错误
    let device = find_device(device_name)?;
    let capture = create_capture(device)?;
    
    Ok(())
}

// 使用 anyhow 进行错误处理
use anyhow::{Result, anyhow};

fn validate_token(token: &str) -> Result<bool> {
    if token.is_empty() {
        return Err(anyhow!("Token不能为空"));
    }
    
    Ok(token.len() > 10)
}
```

#### 文档注释
```rust
/// 处理HTTP数据包的认证信息提取
/// 
/// # Arguments
/// 
/// * `packet` - HTTP数据包对象
/// 
/// # Returns
/// 
/// * `Result<Option<TokenInfo>>` - 提取的Token信息，如果没有找到则返回None
/// 
/// # Examples
/// 
/// ```
/// let token_info = process_http_request(&packet)?;
/// if let Some(token) = token_info {
///     println!("找到Token: {}", token.token);
/// }
/// ```
pub fn process_http_request(packet: &HttpPacket) -> Result<Option<TokenInfo>> {
    // 实现
}
```

#### 异步编程
```rust
// 使用 async/await
async fn fetch_system_data(url: &str) -> Result<String> {
    let response = reqwest::get(url).await?;
    let text = response.text().await?;
    Ok(text)
}

// 并发处理
async fn process_multiple_systems() -> Result<()> {
    let futures = vec![
        fetch_system_data("http://system1.com/api"),
        fetch_system_data("http://system2.com/api"),
        fetch_system_data("http://system3.com/api"),
    ];
    
    let results = tokio::try_join!(futures[0], futures[1], futures[2])?;
    
    Ok(())
}
```

### 2. TypeScript/Vue 代码规范

#### 组件命名
```typescript
// 组件名：帕斯卡命名法
export default defineComponent({
  name: 'NetworkDeviceComponent',
  // ...
})

// 文件名：小写字母 + 连字符
// NetworkDeviceComponent.vue
// packet-filter.component.vue
```

#### 类型定义
```typescript
// 接口定义：帕斯卡命名法
interface TokenStatus {
  system_id: string;
  system_name: string;
  has_token: boolean;
  token_acquired_at?: number;
  token_expires_at?: number;
  status: TokenState;
}

// 类型别名
type NetworkDevice = {
  name: string;
  description: string;
  is_loopback: boolean;
  addresses: string[];
};

// 枚举
enum TokenState {
  Active = 'active',
  Expired = 'expired',
  Waiting = 'waiting',
  Failed = 'failed'
}
```

#### Vue 组件结构
```vue
<template>
  <!-- 模板内容 -->
  <div class="component-container">
    <!-- 使用语义化的类名 -->
    <header class="component-header">
      <h2 class="component-title">{{ title }}</h2>
    </header>
    
    <main class="component-content">
      <!-- 主要内容 -->
    </main>
  </div>
</template>

<script setup lang="ts">
// 1. 导入依赖
import { ref, computed, onMounted } from 'vue'
import { useRouter } from 'vue-router'
import { useAppStore } from '@/stores'

// 2. 定义接口/类型
interface ComponentProps {
  title: string;
  data: any[];
}

// 3. 定义 Props
const props = withDefaults(defineProps<ComponentProps>(), {
  title: '默认标题',
  data: () => []
})

// 4. 定义 Emits
const emit = defineEmits<{
  update: [value: string];
  change: [id: number];
}>()

// 5. 响应式数据
const loading = ref(false)
const items = ref<any[]>([])

// 6. 计算属性
const filteredItems = computed(() => {
  return items.value.filter(item => item.active)
})

// 7. 方法
const handleUpdate = (value: string) => {
  emit('update', value)
}

// 8. 生命周期
onMounted(() => {
  // 初始化逻辑
})
</script>

<style scoped>
/* 使用 scoped 样式 */
.component-container {
  @apply p-4 bg-white rounded-lg shadow;
}

.component-header {
  @apply mb-4 border-b pb-2;
}

.component-title {
  @apply text-xl font-semibold text-gray-800;
}
</style>
```

#### Store 规范
```typescript
// store 文件命名：小驼峰 + Store 后缀
// authStore.ts, proxyStore.ts

export const useAuthStore = defineStore('auth', {
  state: () => ({
    tokenStatus: [] as TokenStatus[],
    tokenEvents: [] as TokenEvent[],
    loading: false,
    error: null as string | null
  }),
  
  getters: {
    // 使用箭头函数和类型标注
    activeTokens: (state): TokenStatus[] => {
      return state.tokenStatus.filter(token => token.status === TokenState.Active)
    },
    
    // 复杂计算属性
    tokenStatistics: (state): TokenStatistics => {
      const active = state.tokenStatus.filter(t => t.status === TokenState.Active).length
      const expired = state.tokenStatus.filter(t => t.status === TokenState.Expired).length
      const waiting = state.tokenStatus.filter(t => t.status === TokenState.Waiting).length
      const failed = state.tokenStatus.filter(t => t.status === TokenState.Failed).length
      
      return { active, expired, waiting, failed }
    }
  },
  
  actions: {
    // 异步方法使用 async/await
    async initialize() {
      this.loading = true
      this.error = null
      
      try {
        await this.setupTokenEventChannel()
        await this.refreshTokenStatus()
      } catch (error) {
        this.error = error instanceof Error ? error.message : '初始化失败'
        throw error
      } finally {
        this.loading = false
      }
    },
    
    // 同步方法
    updateTokenStatus(status: TokenStatus[]) {
      this.tokenStatus = status
    }
  }
})
```

## 🗂️ 项目组织规范

### 目录结构
```
src/
├── components/          # 通用组件
│   ├── base/           # 基础组件
│   ├── business/       # 业务组件
│   └── layout/         # 布局组件
├── views/              # 页面组件
│   ├── Dashboard/      # 每个页面一个文件夹
│   │   ├── index.vue   # 主页面文件
│   │   ├── components/ # 页面专用组件
│   │   └── types.ts    # 页面类型定义
├── stores/             # 状态管理
├── utils/              # 工具函数
├── types/              # 类型定义
├── constants/          # 常量定义
└── assets/             # 静态资源
```

### 文件命名规范
```
# Vue 组件
PascalCase.vue          # 组件文件
kebab-case.component.vue # 复杂组件

# TypeScript 文件
camelCase.ts           # 工具函数
PascalCase.ts          # 类定义
kebab-case.types.ts    # 类型定义

# 样式文件
kebab-case.css
component-name.module.css
```

## 🔧 Git 提交规范

### 提交消息格式
```
<type>(<scope>): <subject>

<body>

<footer>
```

### 提交类型
- **feat**: 新功能
- **fix**: 修复 bug
- **docs**: 文档修改
- **style**: 代码格式修改
- **refactor**: 代码重构
- **test**: 测试相关
- **chore**: 构建过程或辅助工具的变动

### 提交示例
```bash
# 新功能
git commit -m "feat(auth): 添加Token自动刷新功能"

# 修复bug
git commit -m "fix(capture): 修复网络设备检测失败问题"

# 文档更新
git commit -m "docs(readme): 更新环境搭建说明"

# 代码重构
git commit -m "refactor(store): 重构认证状态管理逻辑"
```

### 分支命名规范
```bash
# 功能分支
feature/token-auto-refresh
feature/network-device-selection

# 修复分支
fix/capture-permission-error
fix/ui-display-issue

# 发布分支
release/v0.8.0

# 热修复分支
hotfix/critical-security-fix
```

## 📝 注释规范

### 文件头注释
```typescript
/**
 * 认证状态管理 Store
 * 
 * 负责管理多个业务系统的Token认证状态，包括：
 * - Token状态的实时更新
 * - Token过期检测和预警
 * - Token事件的历史记录
 * 
 * @author 开发团队
 * @version 1.0.0
 * @since 2024-12-01
 */
```

### 函数注释
```typescript
/**
 * 格式化剩余时间显示
 * 
 * @param expiresAt - Token过期时间戳
 * @returns 格式化后的时间字符串，如 "2小时30分钟" 或 "已过期"
 */
function formatRemainingTime(expiresAt: number): string {
  // 实现
}
```

### 复杂逻辑注释
```typescript
// 计算Token剩余时间
// 1. 获取当前时间戳
const now = Date.now()

// 2. 计算时间差（毫秒）
const diff = expiresAt - now

// 3. 判断是否过期
if (diff <= 0) {
  return '已过期'
}

// 4. 格式化显示
const hours = Math.floor(diff / (1000 * 60 * 60))
const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60))
```

## 🧪 测试规范

### 单元测试
```typescript
// 测试文件命名：*.test.ts
// utils.test.ts, store.test.ts

import { describe, test, expect } from 'vitest'
import { formatRemainingTime } from '@/utils/time'

describe('时间工具函数', () => {
  test('应该正确格式化剩余时间', () => {
    const now = Date.now()
    const twoHoursLater = now + 2 * 60 * 60 * 1000
    
    const result = formatRemainingTime(twoHoursLater)
    
    expect(result).toBe('2小时0分钟')
  })
  
  test('应该处理过期时间', () => {
    const now = Date.now()
    const oneHourAgo = now - 1 * 60 * 60 * 1000
    
    const result = formatRemainingTime(oneHourAgo)
    
    expect(result).toBe('已过期')
  })
})
```

### 组件测试
```typescript
import { mount } from '@vue/test-utils'
import { describe, test, expect } from 'vitest'
import TokenStatusCard from '@/components/TokenStatusCard.vue'

describe('TokenStatusCard', () => {
  test('应该正确显示Token状态', async () => {
    const wrapper = mount(TokenStatusCard, {
      props: {
        tokenStatus: {
          system_id: 'test_system',
          system_name: '测试系统',
          has_token: true,
          status: 'active'
        }
      }
    })
    
    expect(wrapper.text()).toContain('测试系统')
    expect(wrapper.text()).toContain('正常')
  })
})
```

## 🚀 性能优化规范

### 前端性能
```typescript
// 1. 使用 computed 而不是 methods
const filteredData = computed(() => {
  return data.value.filter(item => item.active)
})

// 2. 避免在模板中使用复杂计算
// ❌ 错误
<template>
  <div>{{ data.filter(item => item.active).length }}</div>
</template>

// ✅ 正确
<template>
  <div>{{ activeCount }}</div>
</template>

// 3. 使用 v-memo 优化列表渲染
<template>
  <div v-for="item in list" :key="item.id" v-memo="[item.id, item.status]">
    {{ item.name }}
  </div>
</template>
```

### 后端性能
```rust
// 1. 使用引用而不是值传递
fn process_packet(packet: &HttpPacket) -> Result<()> {
    // 避免不必要的克隆
}

// 2. 使用 Arc 和 Mutex 进行并发控制
use std::sync::{Arc, Mutex};
use once_cell::sync::OnceCell;

static SHARED_STATE: OnceCell<Arc<Mutex<State>>> = OnceCell::new();

// 3. 使用 try_lock 避免阻塞
if let Ok(guard) = state.try_lock() {
    // 处理逻辑
} else {
    // 处理锁繁忙的情况
}
```

## 🔒 安全规范

### 敏感信息处理
```typescript
// ❌ 错误：不要在日志中输出完整Token
console.log('Token:', token)

// ✅ 正确：只输出Token长度或前几位
console.log('Token长度:', token.length)
console.log('Token前缀:', token.substring(0, 8) + '...')
```

### 输入验证
```typescript
// 验证用户输入
function validateInput(input: string): boolean {
  // 检查长度
  if (input.length > 1000) {
    return false
  }
  
  // 检查特殊字符
  const dangerousChars = /<script|javascript:|data:/i
  if (dangerousChars.test(input)) {
    return false
  }
  
  return true
}
```

## 📊 代码质量检查

### ESLint 配置
```json
{
  "extends": [
    "@vue/eslint-config-typescript",
    "@vue/eslint-config-prettier"
  ],
  "rules": {
    "no-console": "warn",
    "no-debugger": "error",
    "@typescript-eslint/no-unused-vars": "error",
    "vue/no-unused-components": "error"
  }
}
```

### 代码审查清单
- [ ] 代码风格是否符合规范
- [ ] 是否有适当的错误处理
- [ ] 是否有必要的注释
- [ ] 是否有安全隐患
- [ ] 性能是否合理
- [ ] 测试覆盖率是否足够
- [ ] 提交信息是否规范

## 📚 文档规范

### API 文档
```typescript
/**
 * 获取所有Token状态
 * 
 * @returns Promise<TokenStatus[]> Token状态列表
 * @throws Error 当认证系统未初始化时抛出异常
 * 
 * @example
 * ```typescript
 * const tokens = await getAllTokenStatus()
 * console.log('活跃Token数量:', tokens.filter(t => t.status === 'active').length)
 * ```
 */
async function getAllTokenStatus(): Promise<TokenStatus[]> {
  // 实现
}
```

### README 文档
```markdown
# 组件名称

## 功能描述
简要描述组件的功能和用途

## 使用方法
\`\`\`typescript
import { ComponentName } from '@/components'

// 使用示例
\`\`\`

## API
| 属性 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| prop1 | string | '' | 属性说明 |

## 注意事项
- 使用时需要注意的事项
- 已知问题和限制
```

遵循这些开发规范，可以确保代码质量、提高开发效率、减少bug，并提升团队协作效率。