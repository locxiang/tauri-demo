# è°ƒè¯•æŒ‡å—

## ğŸ” è°ƒè¯•å·¥å…·å’Œæ–¹æ³•

### 1. å‰ç«¯è°ƒè¯•

#### Vue DevTools
```bash
# å¯åŠ¨å¼€å‘æ¨¡å¼æ—¶è‡ªåŠ¨å¯ç”¨
pnpm tauri dev

# åœ¨æµè§ˆå™¨ä¸­è®¿é—®å¼€å‘è€…å·¥å…·
# å¿«æ·é”®ï¼šF12 æˆ– Ctrl/Cmd + Shift + I
```

#### Chrome DevTools è°ƒè¯•
```typescript
// 1. åœ¨ä»£ç ä¸­æ·»åŠ æ–­ç‚¹
function handleTokenUpdate(token: TokenStatus) {
  debugger; // æµè§ˆå™¨ä¼šåœ¨æ­¤å¤„æš‚åœ
  console.log('Tokenæ›´æ–°:', token);
}

// 2. ä½¿ç”¨ console è°ƒè¯•
console.log('å½“å‰çŠ¶æ€:', store.tokenStatus);
console.table(store.tokenStatus); // è¡¨æ ¼å½¢å¼æ˜¾ç¤º
console.group('Tokenå¤„ç†');
console.log('ç³»ç»ŸID:', systemId);
console.log('Tokenå€¼:', token);
console.groupEnd();
```

#### æ€§èƒ½åˆ†æ
```typescript
// æ€§èƒ½æ ‡è®°
performance.mark('start-token-process');
// æ‰§è¡Œä¸šåŠ¡é€»è¾‘
performance.mark('end-token-process');
performance.measure('token-process', 'start-token-process', 'end-token-process');

// æŸ¥çœ‹æ€§èƒ½æŒ‡æ ‡
console.log(performance.getEntriesByType('measure'));
```

### 2. Rust åç«¯è°ƒè¯•

#### æ—¥å¿—è°ƒè¯•
```rust
// é…ç½®è¯¦ç»†æ—¥å¿—
use log::{debug, info, warn, error};

// åœ¨ä»£ç ä¸­æ·»åŠ æ—¥å¿—
pub fn process_http_packet(packet: &HttpPacket) -> Result<()> {
    debug!("ğŸ” å¼€å§‹å¤„ç†HTTPåŒ…: {} {}", 
           packet.method.as_ref().unwrap_or(&"UNKNOWN".to_string()),
           packet.path.as_ref().unwrap_or(&"/".to_string()));
    
    info!("ğŸ“¦ æ•°æ®åŒ…ä¿¡æ¯: {}:{} -> {}:{}", 
          packet.src_ip, packet.src_port, 
          packet.dst_ip, packet.dst_port);
    
    // å¤„ç†é€»è¾‘
    match result {
        Ok(_) => info!("âœ… å¤„ç†æˆåŠŸ"),
        Err(e) => error!("âŒ å¤„ç†å¤±è´¥: {}", e),
    }
    
    Ok(())
}
```

#### ç¯å¢ƒå˜é‡é…ç½®
```bash
# å¯ç”¨è¯¦ç»†æ—¥å¿—
export RUST_LOG=debug
export RUST_BACKTRACE=1

# é’ˆå¯¹ç‰¹å®šæ¨¡å—çš„æ—¥å¿—
export RUST_LOG=big_data_rpa_v4::auth=debug,big_data_rpa_v4::capture=trace

# å¯åŠ¨åº”ç”¨
pnpm tauri dev
```

#### VS Code è°ƒè¯•é…ç½®
```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug Tauri App",
      "type": "lldb",
      "request": "launch",
      "program": "${workspaceFolder}/src-tauri/target/debug/big-data-rpa-v4",
      "args": [],
      "cwd": "${workspaceFolder}",
      "environment": [
        {
          "name": "RUST_LOG",
          "value": "debug"
        },
        {
          "name": "RUST_BACKTRACE",
          "value": "1"
        }
      ],
      "console": "integratedTerminal",
      "sourceLanguages": ["rust"]
    }
  ]
}
```

## ğŸ› å¸¸è§é—®é¢˜è°ƒè¯•

### 1. ç½‘ç»œæŠ“åŒ…é—®é¢˜

#### æƒé™é—®é¢˜è°ƒè¯•
```rust
// æ£€æŸ¥æƒé™çš„è°ƒè¯•å‡½æ•°
#[tauri::command]
pub fn debug_capture_permissions() -> String {
    let mut debug_info = String::new();
    
    #[cfg(target_os = "macos")]
    {
        let chmodbpf_path = "/Library/LaunchDaemons/org.wireshark.ChmodBPF.plist";
        if std::path::Path::new(chmodbpf_path).exists() {
            debug_info.push_str("âœ… ChmodBPF plistæ–‡ä»¶å­˜åœ¨\n");
        } else {
            debug_info.push_str("âŒ ChmodBPF plistæ–‡ä»¶ä¸å­˜åœ¨\n");
        }
        
        // æ£€æŸ¥BPFè®¾å¤‡
        for i in 0..10 {
            let bpf_path = format!("/dev/bpf{}", i);
            if std::path::Path::new(&bpf_path).exists() {
                debug_info.push_str(&format!("âœ… BPFè®¾å¤‡å­˜åœ¨: {}\n", bpf_path));
            }
        }
    }
    
    #[cfg(target_os = "windows")]
    {
        let npcap_path = "C:\\Windows\\System32\\Npcap";
        if std::path::Path::new(npcap_path).exists() {
            debug_info.push_str("âœ… Npcapå®‰è£…ç›®å½•å­˜åœ¨\n");
        } else {
            debug_info.push_str("âŒ Npcapå®‰è£…ç›®å½•ä¸å­˜åœ¨\n");
        }
    }
    
    debug_info
}
```

#### ç½‘ç»œè®¾å¤‡è°ƒè¯•
```rust
// è°ƒè¯•ç½‘ç»œè®¾å¤‡æ£€æµ‹
#[tauri::command]
pub fn debug_network_devices() -> Vec<String> {
    let mut debug_info = Vec::new();
    
    match pcap::Device::list() {
        Ok(devices) => {
            for device in devices {
                let info = format!(
                    "è®¾å¤‡: {} | æè¿°: {} | åœ°å€: {:?} | å›ç¯: {}",
                    device.name,
                    device.desc.unwrap_or("æ— æè¿°".to_string()),
                    device.addresses.iter().map(|a| a.addr.to_string()).collect::<Vec<_>>(),
                    device.flags.is_loopback()
                );
                debug_info.push(info);
            }
        }
        Err(e) => {
            debug_info.push(format!("âŒ è·å–è®¾å¤‡åˆ—è¡¨å¤±è´¥: {}", e));
        }
    }
    
    debug_info
}
```

### 2. è®¤è¯ç³»ç»Ÿè°ƒè¯•

#### Tokenæå–è°ƒè¯•
```rust
// è°ƒè¯•Tokenæå–è¿‡ç¨‹
impl SystemAuth for SystemBI {
    fn process_http_request(&mut self, packet: &HttpPacket) -> Result<Option<TokenInfo>> {
        debug!("ğŸ” [{}] å¤„ç†HTTPè¯·æ±‚", self.system_name());
        debug!("ğŸ“ URL: {}", packet.path.as_ref().unwrap_or(&"/".to_string()));
        
        // æ£€æŸ¥URLåŒ¹é…
        if !self.url_regex.is_match(&packet.path.as_ref().unwrap_or(&"/".to_string())) {
            debug!("âŒ URLä¸åŒ¹é…æ­£åˆ™è¡¨è¾¾å¼");
            return Ok(None);
        }
        
        debug!("âœ… URLåŒ¹é…æˆåŠŸ");
        
        // æŸ¥æ‰¾Cookieå¤´
        let cookie_header = packet.headers.iter()
            .find(|(name, _)| name.to_lowercase() == "cookie");
        
        if let Some((_, cookie_value)) = cookie_header {
            debug!("ğŸª æ‰¾åˆ°Cookieå¤´: {}", cookie_value);
            
            // æå–ç‰¹å®šCookieå€¼
            if let Some(token) = self.extract_token_from_cookie(cookie_value) {
                debug!("ğŸ¯ æå–åˆ°Token: {}...", &token[..std::cmp::min(token.len(), 10)]);
                
                // éªŒè¯Token
                if self.token_validator.validate(&token) {
                    debug!("âœ… TokenéªŒè¯é€šè¿‡");
                    return Ok(Some(TokenInfo {
                        token: Some(token),
                        acquired_at: Some(chrono::Utc::now().timestamp() as u64),
                        expires_at: Some(chrono::Utc::now().timestamp() as u64 + 3600),
                        is_valid: true,
                    }));
                } else {
                    debug!("âŒ TokenéªŒè¯å¤±è´¥");
                }
            } else {
                debug!("âŒ Cookieä¸­æœªæ‰¾åˆ°ç›®æ ‡Token");
            }
        } else {
            debug!("âŒ æœªæ‰¾åˆ°Cookieå¤´");
        }
        
        Ok(None)
    }
}
```

#### å‰ç«¯è®¤è¯çŠ¶æ€è°ƒè¯•
```typescript
// åœ¨è®¤è¯ Store ä¸­æ·»åŠ è°ƒè¯•ä¿¡æ¯
export const useAuthStore = defineStore('auth', {
  state: () => ({
    tokenStatus: [] as TokenStatus[],
    tokenEvents: [] as TokenEvent[],
    debugInfo: {
      lastUpdate: 0,
      channelConnected: false,
      eventCount: 0
    }
  }),
  
  actions: {
    async setupTokenEventChannel() {
      console.log('ğŸ”— è®¾ç½®Tokenäº‹ä»¶é€šé“...');
      
      try {
        const channel = new Channel<TokenEvent>();
        
        channel.onmessage = (event) => {
          console.log('ğŸ“¨ æ”¶åˆ°Tokenäº‹ä»¶:', event);
          this.debugInfo.eventCount++;
          this.debugInfo.lastUpdate = Date.now();
          
          this.handleTokenEvent(event);
        };
        
        await invoke('set_token_event_channel', { channel });
        this.debugInfo.channelConnected = true;
        
        console.log('âœ… Tokenäº‹ä»¶é€šé“è®¾ç½®æˆåŠŸ');
      } catch (error) {
        console.error('âŒ è®¾ç½®Tokenäº‹ä»¶é€šé“å¤±è´¥:', error);
        this.debugInfo.channelConnected = false;
      }
    },
    
    handleTokenEvent(event: TokenEvent) {
      console.group('ğŸ¯ å¤„ç†Tokenäº‹ä»¶');
      console.log('äº‹ä»¶ç±»å‹:', event.type);
      console.log('ç³»ç»ŸID:', event.system_id);
      console.log('ç³»ç»Ÿåç§°:', event.system_name);
      
      switch (event.type) {
        case 'TokenAcquired':
          console.log('Tokenè·å–æˆåŠŸ:', event.token?.substring(0, 10) + '...');
          break;
        case 'TokenExpired':
          console.log('Tokenå·²è¿‡æœŸ');
          break;
        case 'TokenFailed':
          console.log('Tokenè·å–å¤±è´¥:', event.error);
          break;
      }
      
      console.groupEnd();
      
      // æ›´æ–°çŠ¶æ€
      this.updateTokenFromEvent(event);
    }
  }
});
```

### 3. æ€§èƒ½é—®é¢˜è°ƒè¯•

#### å‰ç«¯æ€§èƒ½åˆ†æ
```typescript
// æ€§èƒ½ç›‘æ§è£…é¥°å™¨
function performanceMonitor(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  
  descriptor.value = function (...args: any[]) {
    const start = performance.now();
    console.log(`ğŸš€ å¼€å§‹æ‰§è¡Œ ${propertyKey}`);
    
    const result = originalMethod.apply(this, args);
    
    const end = performance.now();
    console.log(`â±ï¸ ${propertyKey} æ‰§è¡Œæ—¶é—´: ${(end - start).toFixed(2)}ms`);
    
    return result;
  };
  
  return descriptor;
}

// ä½¿ç”¨ç¤ºä¾‹
class TokenManager {
  @performanceMonitor
  async processTokens() {
    // å¤„ç†é€»è¾‘
  }
}
```

#### å†…å­˜ä½¿ç”¨ç›‘æ§
```typescript
// å†…å­˜ä½¿ç”¨ç›‘æ§
function logMemoryUsage() {
  if (performance.memory) {
    console.log('ğŸ’¾ å†…å­˜ä½¿ç”¨æƒ…å†µ:');
    console.log(`å·²ä½¿ç”¨: ${(performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2)} MB`);
    console.log(`æ€»è®¡: ${(performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2)} MB`);
    console.log(`é™åˆ¶: ${(performance.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2)} MB`);
  }
}

// å®šæœŸç›‘æ§
setInterval(logMemoryUsage, 30000); // æ¯30ç§’è®°å½•ä¸€æ¬¡
```

#### Rust æ€§èƒ½åˆ†æ
```rust
// ä½¿ç”¨ std::time::Instant è¿›è¡Œæ€§èƒ½æµ‹é‡
use std::time::Instant;

pub fn process_large_data() -> Result<()> {
    let start = Instant::now();
    info!("ğŸš€ å¼€å§‹å¤„ç†å¤§é‡æ•°æ®");
    
    // å¤„ç†é€»è¾‘
    let processed_items = 0;
    
    let duration = start.elapsed();
    info!("â±ï¸ å¤„ç†å®Œæˆï¼Œè€—æ—¶: {:?}ï¼Œå¤„ç†é¡¹ç›®: {}", duration, processed_items);
    
    Ok(())
}

// å†…å­˜ä½¿ç”¨ç›‘æ§
fn log_memory_usage() {
    #[cfg(unix)]
    {
        use std::fs;
        if let Ok(status) = fs::read_to_string("/proc/self/status") {
            for line in status.lines() {
                if line.starts_with("VmRSS:") {
                    info!("ğŸ’¾ å†…å­˜ä½¿ç”¨: {}", line);
                }
            }
        }
    }
}
```

## ğŸ”§ è°ƒè¯•å‘½ä»¤å’Œå¿«æ·é”®

### å¼€å‘ç¯å¢ƒè°ƒè¯•
```bash
# å¯åŠ¨è¯¦ç»†æ—¥å¿—çš„å¼€å‘æ¨¡å¼
RUST_LOG=debug RUST_BACKTRACE=1 pnpm tauri dev

# åªå¯åŠ¨å‰ç«¯å¼€å‘æœåŠ¡å™¨
pnpm dev

# å•ç‹¬æ„å»ºåç«¯
cd src-tauri && cargo build

# è¿è¡Œæµ‹è¯•
pnpm test
cargo test
```

### æµè§ˆå™¨è°ƒè¯•å¿«æ·é”®
```
F12                    # æ‰“å¼€å¼€å‘è€…å·¥å…·
Ctrl/Cmd + Shift + I   # æ‰“å¼€å¼€å‘è€…å·¥å…·
Ctrl/Cmd + Shift + C   # å…ƒç´ é€‰æ‹©å™¨
Ctrl/Cmd + Shift + J   # æ§åˆ¶å°
Ctrl/Cmd + R           # åˆ·æ–°é¡µé¢
Ctrl/Cmd + Shift + R   # å¼ºåˆ¶åˆ·æ–°
F8                     # æš‚åœ/ç»§ç»­è„šæœ¬æ‰§è¡Œ
F10                    # å•æ­¥è°ƒè¯•
F11                    # è¿›å…¥å‡½æ•°
```

## ğŸ“Š è°ƒè¯•ä¿¡æ¯æ”¶é›†

### ç³»ç»Ÿä¿¡æ¯æ”¶é›†
```typescript
// æ”¶é›†ç³»ç»Ÿè°ƒè¯•ä¿¡æ¯
async function collectDebugInfo() {
  const debugInfo = {
    // åº”ç”¨ä¿¡æ¯
    app: {
      version: await invoke('get_app_version'),
      platform: await invoke('get_platform'),
      arch: await invoke('get_arch'),
    },
    
    // æƒé™ä¿¡æ¯
    permissions: {
      capture: await invoke('debug_capture_permissions'),
      devices: await invoke('debug_network_devices'),
    },
    
    // çŠ¶æ€ä¿¡æ¯
    status: {
      captureRunning: await invoke('get_capture_status'),
      tokenStatus: await invoke('get_all_token_status'),
    },
    
    // æµè§ˆå™¨ä¿¡æ¯
    browser: {
      userAgent: navigator.userAgent,
      language: navigator.language,
      cookieEnabled: navigator.cookieEnabled,
    },
    
    // æ€§èƒ½ä¿¡æ¯
    performance: {
      memory: performance.memory,
      timing: performance.timing,
    },
  };
  
  return debugInfo;
}
```

### é”™è¯¯æŠ¥å‘Šç”Ÿæˆ
```typescript
// ç”Ÿæˆé”™è¯¯æŠ¥å‘Š
function generateErrorReport(error: Error) {
  const report = {
    timestamp: new Date().toISOString(),
    error: {
      message: error.message,
      stack: error.stack,
      name: error.name,
    },
    context: {
      url: window.location.href,
      userAgent: navigator.userAgent,
      // æ·»åŠ æ›´å¤šä¸Šä¸‹æ–‡ä¿¡æ¯
    },
    logs: getRecentLogs(), // è·å–æœ€è¿‘çš„æ—¥å¿—
  };
  
  console.error('ğŸ“‹ é”™è¯¯æŠ¥å‘Š:', report);
  
  // å¯é€‰ï¼šå‘é€åˆ°é”™è¯¯æ”¶é›†æœåŠ¡
  // sendErrorReport(report);
  
  return report;
}
```

## ğŸ” ç½‘ç»œè°ƒè¯•

### HTTP è¯·æ±‚è°ƒè¯•
```typescript
// æ‹¦æˆªå’Œè°ƒè¯• HTTP è¯·æ±‚
const originalFetch = window.fetch;
window.fetch = async function(input, init) {
  console.log('ğŸŒ å‘é€è¯·æ±‚:', input, init);
  
  try {
    const response = await originalFetch(input, init);
    console.log('ğŸ“¡ æ”¶åˆ°å“åº”:', response.status, response.statusText);
    return response;
  } catch (error) {
    console.error('âŒ è¯·æ±‚å¤±è´¥:', error);
    throw error;
  }
};
```

### Tauri å‘½ä»¤è°ƒè¯•
```typescript
// åŒ…è£… Tauri invoke å‡½æ•°è¿›è¡Œè°ƒè¯•
const originalInvoke = invoke;
window.invoke = async function(command: string, args?: any) {
  console.log(`ğŸ”§ è°ƒç”¨å‘½ä»¤: ${command}`, args);
  
  try {
    const result = await originalInvoke(command, args);
    console.log(`âœ… å‘½ä»¤æˆåŠŸ: ${command}`, result);
    return result;
  } catch (error) {
    console.error(`âŒ å‘½ä»¤å¤±è´¥: ${command}`, error);
    throw error;
  }
};
```

## ğŸ“ è°ƒè¯•æœ€ä½³å®è·µ

### 1. æ—¥å¿—çº§åˆ«ä½¿ç”¨
```rust
// åˆç†ä½¿ç”¨æ—¥å¿—çº§åˆ«
trace!("è¯¦ç»†çš„æ‰§è¡Œæµç¨‹ä¿¡æ¯");    // å¼€å‘è°ƒè¯•
debug!("è°ƒè¯•ä¿¡æ¯");             // å¼€å‘è°ƒè¯•
info!("ä¸€èˆ¬ä¿¡æ¯");              // ç”Ÿäº§ç¯å¢ƒ
warn!("è­¦å‘Šä¿¡æ¯");              // ç”Ÿäº§ç¯å¢ƒ
error!("é”™è¯¯ä¿¡æ¯");             // ç”Ÿäº§ç¯å¢ƒ
```

### 2. ç»“æ„åŒ–æ—¥å¿—
```typescript
// ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—
const logger = {
  debug: (message: string, data?: any) => {
    console.log(`[DEBUG] ${new Date().toISOString()} ${message}`, data);
  },
  info: (message: string, data?: any) => {
    console.log(`[INFO] ${new Date().toISOString()} ${message}`, data);
  },
  error: (message: string, error?: Error) => {
    console.error(`[ERROR] ${new Date().toISOString()} ${message}`, error);
  },
};
```

### 3. è°ƒè¯•å¼€å…³
```typescript
// ä½¿ç”¨ç¯å¢ƒå˜é‡æ§åˆ¶è°ƒè¯•
const DEBUG = import.meta.env.DEV;

function debugLog(message: string, data?: any) {
  if (DEBUG) {
    console.log(`[DEBUG] ${message}`, data);
  }
}
```

### 4. é”™è¯¯è¾¹ç•Œ
```vue
<!-- Vue é”™è¯¯è¾¹ç•Œç»„ä»¶ -->
<template>
  <div v-if="error" class="error-boundary">
    <h2>å‡ºç°é”™è¯¯</h2>
    <p>{{ error.message }}</p>
    <button @click="retry">é‡è¯•</button>
  </div>
  <slot v-else />
</template>

<script setup>
import { ref, onErrorCaptured } from 'vue'

const error = ref(null)

onErrorCaptured((err) => {
  error.value = err
  console.error('ç»„ä»¶é”™è¯¯:', err)
  return false
})

function retry() {
  error.value = null
}
</script>
```

é€šè¿‡è¿™äº›è°ƒè¯•æ–¹æ³•å’Œå·¥å…·ï¼Œå¯ä»¥æœ‰æ•ˆåœ°å®šä½å’Œè§£å†³å¼€å‘è¿‡ç¨‹ä¸­é‡åˆ°çš„é—®é¢˜ï¼Œæé«˜å¼€å‘æ•ˆç‡å’Œä»£ç è´¨é‡ã€‚