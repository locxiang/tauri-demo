# 调试指南

## 🔍 调试工具和方法

### 1. 前端调试

#### Vue DevTools
```bash
# 启动开发模式时自动启用
pnpm tauri dev

# 在浏览器中访问开发者工具
# 快捷键：F12 或 Ctrl/Cmd + Shift + I
```

#### Chrome DevTools 调试
```typescript
// 1. 在代码中添加断点
function handleTokenUpdate(token: TokenStatus) {
  debugger; // 浏览器会在此处暂停
  console.log('Token更新:', token);
}

// 2. 使用 console 调试
console.log('当前状态:', store.tokenStatus);
console.table(store.tokenStatus); // 表格形式显示
console.group('Token处理');
console.log('系统ID:', systemId);
console.log('Token值:', token);
console.groupEnd();
```

#### 性能分析
```typescript
// 性能标记
performance.mark('start-token-process');
// 执行业务逻辑
performance.mark('end-token-process');
performance.measure('token-process', 'start-token-process', 'end-token-process');

// 查看性能指标
console.log(performance.getEntriesByType('measure'));
```

### 2. Rust 后端调试

#### 日志调试
```rust
// 配置详细日志
use log::{debug, info, warn, error};

// 在代码中添加日志
pub fn process_http_packet(packet: &HttpPacket) -> Result<()> {
    debug!("🔍 开始处理HTTP包: {} {}", 
           packet.method.as_ref().unwrap_or(&"UNKNOWN".to_string()),
           packet.path.as_ref().unwrap_or(&"/".to_string()));
    
    info!("📦 数据包信息: {}:{} -> {}:{}", 
          packet.src_ip, packet.src_port, 
          packet.dst_ip, packet.dst_port);
    
    // 处理逻辑
    match result {
        Ok(_) => info!("✅ 处理成功"),
        Err(e) => error!("❌ 处理失败: {}", e),
    }
    
    Ok(())
}
```

#### 环境变量配置
```bash
# 启用详细日志
export RUST_LOG=debug
export RUST_BACKTRACE=1

# 针对特定模块的日志
export RUST_LOG=big_data_rpa_v4::auth=debug,big_data_rpa_v4::capture=trace

# 启动应用
pnpm tauri dev
```

#### VS Code 调试配置
```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug Tauri App",
      "type": "lldb",
      "request": "launch",
      "program": "${workspaceFolder}/src-tauri/target/debug/big-data-rpa-v4",
      "args": [],
      "cwd": "${workspaceFolder}",
      "environment": [
        {
          "name": "RUST_LOG",
          "value": "debug"
        },
        {
          "name": "RUST_BACKTRACE",
          "value": "1"
        }
      ],
      "console": "integratedTerminal",
      "sourceLanguages": ["rust"]
    }
  ]
}
```

## 🐛 常见问题调试

### 1. 网络抓包问题

#### 权限问题调试
```rust
// 检查权限的调试函数
#[tauri::command]
pub fn debug_capture_permissions() -> String {
    let mut debug_info = String::new();
    
    #[cfg(target_os = "macos")]
    {
        let chmodbpf_path = "/Library/LaunchDaemons/org.wireshark.ChmodBPF.plist";
        if std::path::Path::new(chmodbpf_path).exists() {
            debug_info.push_str("✅ ChmodBPF plist文件存在\n");
        } else {
            debug_info.push_str("❌ ChmodBPF plist文件不存在\n");
        }
        
        // 检查BPF设备
        for i in 0..10 {
            let bpf_path = format!("/dev/bpf{}", i);
            if std::path::Path::new(&bpf_path).exists() {
                debug_info.push_str(&format!("✅ BPF设备存在: {}\n", bpf_path));
            }
        }
    }
    
    #[cfg(target_os = "windows")]
    {
        let npcap_path = "C:\\Windows\\System32\\Npcap";
        if std::path::Path::new(npcap_path).exists() {
            debug_info.push_str("✅ Npcap安装目录存在\n");
        } else {
            debug_info.push_str("❌ Npcap安装目录不存在\n");
        }
    }
    
    debug_info
}
```

#### 网络设备调试
```rust
// 调试网络设备检测
#[tauri::command]
pub fn debug_network_devices() -> Vec<String> {
    let mut debug_info = Vec::new();
    
    match pcap::Device::list() {
        Ok(devices) => {
            for device in devices {
                let info = format!(
                    "设备: {} | 描述: {} | 地址: {:?} | 回环: {}",
                    device.name,
                    device.desc.unwrap_or("无描述".to_string()),
                    device.addresses.iter().map(|a| a.addr.to_string()).collect::<Vec<_>>(),
                    device.flags.is_loopback()
                );
                debug_info.push(info);
            }
        }
        Err(e) => {
            debug_info.push(format!("❌ 获取设备列表失败: {}", e));
        }
    }
    
    debug_info
}
```

### 2. 认证系统调试

#### Token提取调试
```rust
// 调试Token提取过程
impl SystemAuth for SystemBI {
    fn process_http_request(&mut self, packet: &HttpPacket) -> Result<Option<TokenInfo>> {
        debug!("🔍 [{}] 处理HTTP请求", self.system_name());
        debug!("📍 URL: {}", packet.path.as_ref().unwrap_or(&"/".to_string()));
        
        // 检查URL匹配
        if !self.url_regex.is_match(&packet.path.as_ref().unwrap_or(&"/".to_string())) {
            debug!("❌ URL不匹配正则表达式");
            return Ok(None);
        }
        
        debug!("✅ URL匹配成功");
        
        // 查找Cookie头
        let cookie_header = packet.headers.iter()
            .find(|(name, _)| name.to_lowercase() == "cookie");
        
        if let Some((_, cookie_value)) = cookie_header {
            debug!("🍪 找到Cookie头: {}", cookie_value);
            
            // 提取特定Cookie值
            if let Some(token) = self.extract_token_from_cookie(cookie_value) {
                debug!("🎯 提取到Token: {}...", &token[..std::cmp::min(token.len(), 10)]);
                
                // 验证Token
                if self.token_validator.validate(&token) {
                    debug!("✅ Token验证通过");
                    return Ok(Some(TokenInfo {
                        token: Some(token),
                        acquired_at: Some(chrono::Utc::now().timestamp() as u64),
                        expires_at: Some(chrono::Utc::now().timestamp() as u64 + 3600),
                        is_valid: true,
                    }));
                } else {
                    debug!("❌ Token验证失败");
                }
            } else {
                debug!("❌ Cookie中未找到目标Token");
            }
        } else {
            debug!("❌ 未找到Cookie头");
        }
        
        Ok(None)
    }
}
```

#### 前端认证状态调试
```typescript
// 在认证 Store 中添加调试信息
export const useAuthStore = defineStore('auth', {
  state: () => ({
    tokenStatus: [] as TokenStatus[],
    tokenEvents: [] as TokenEvent[],
    debugInfo: {
      lastUpdate: 0,
      channelConnected: false,
      eventCount: 0
    }
  }),
  
  actions: {
    async setupTokenEventChannel() {
      console.log('🔗 设置Token事件通道...');
      
      try {
        const channel = new Channel<TokenEvent>();
        
        channel.onmessage = (event) => {
          console.log('📨 收到Token事件:', event);
          this.debugInfo.eventCount++;
          this.debugInfo.lastUpdate = Date.now();
          
          this.handleTokenEvent(event);
        };
        
        await invoke('set_token_event_channel', { channel });
        this.debugInfo.channelConnected = true;
        
        console.log('✅ Token事件通道设置成功');
      } catch (error) {
        console.error('❌ 设置Token事件通道失败:', error);
        this.debugInfo.channelConnected = false;
      }
    },
    
    handleTokenEvent(event: TokenEvent) {
      console.group('🎯 处理Token事件');
      console.log('事件类型:', event.type);
      console.log('系统ID:', event.system_id);
      console.log('系统名称:', event.system_name);
      
      switch (event.type) {
        case 'TokenAcquired':
          console.log('Token获取成功:', event.token?.substring(0, 10) + '...');
          break;
        case 'TokenExpired':
          console.log('Token已过期');
          break;
        case 'TokenFailed':
          console.log('Token获取失败:', event.error);
          break;
      }
      
      console.groupEnd();
      
      // 更新状态
      this.updateTokenFromEvent(event);
    }
  }
});
```

### 3. 性能问题调试

#### 前端性能分析
```typescript
// 性能监控装饰器
function performanceMonitor(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  
  descriptor.value = function (...args: any[]) {
    const start = performance.now();
    console.log(`🚀 开始执行 ${propertyKey}`);
    
    const result = originalMethod.apply(this, args);
    
    const end = performance.now();
    console.log(`⏱️ ${propertyKey} 执行时间: ${(end - start).toFixed(2)}ms`);
    
    return result;
  };
  
  return descriptor;
}

// 使用示例
class TokenManager {
  @performanceMonitor
  async processTokens() {
    // 处理逻辑
  }
}
```

#### 内存使用监控
```typescript
// 内存使用监控
function logMemoryUsage() {
  if (performance.memory) {
    console.log('💾 内存使用情况:');
    console.log(`已使用: ${(performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2)} MB`);
    console.log(`总计: ${(performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2)} MB`);
    console.log(`限制: ${(performance.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2)} MB`);
  }
}

// 定期监控
setInterval(logMemoryUsage, 30000); // 每30秒记录一次
```

#### Rust 性能分析
```rust
// 使用 std::time::Instant 进行性能测量
use std::time::Instant;

pub fn process_large_data() -> Result<()> {
    let start = Instant::now();
    info!("🚀 开始处理大量数据");
    
    // 处理逻辑
    let processed_items = 0;
    
    let duration = start.elapsed();
    info!("⏱️ 处理完成，耗时: {:?}，处理项目: {}", duration, processed_items);
    
    Ok(())
}

// 内存使用监控
fn log_memory_usage() {
    #[cfg(unix)]
    {
        use std::fs;
        if let Ok(status) = fs::read_to_string("/proc/self/status") {
            for line in status.lines() {
                if line.starts_with("VmRSS:") {
                    info!("💾 内存使用: {}", line);
                }
            }
        }
    }
}
```

## 🔧 调试命令和快捷键

### 开发环境调试
```bash
# 启动详细日志的开发模式
RUST_LOG=debug RUST_BACKTRACE=1 pnpm tauri dev

# 只启动前端开发服务器
pnpm dev

# 单独构建后端
cd src-tauri && cargo build

# 运行测试
pnpm test
cargo test
```

### 浏览器调试快捷键
```
F12                    # 打开开发者工具
Ctrl/Cmd + Shift + I   # 打开开发者工具
Ctrl/Cmd + Shift + C   # 元素选择器
Ctrl/Cmd + Shift + J   # 控制台
Ctrl/Cmd + R           # 刷新页面
Ctrl/Cmd + Shift + R   # 强制刷新
F8                     # 暂停/继续脚本执行
F10                    # 单步调试
F11                    # 进入函数
```

## 📊 调试信息收集

### 系统信息收集
```typescript
// 收集系统调试信息
async function collectDebugInfo() {
  const debugInfo = {
    // 应用信息
    app: {
      version: await invoke('get_app_version'),
      platform: await invoke('get_platform'),
      arch: await invoke('get_arch'),
    },
    
    // 权限信息
    permissions: {
      capture: await invoke('debug_capture_permissions'),
      devices: await invoke('debug_network_devices'),
    },
    
    // 状态信息
    status: {
      captureRunning: await invoke('get_capture_status'),
      tokenStatus: await invoke('get_all_token_status'),
    },
    
    // 浏览器信息
    browser: {
      userAgent: navigator.userAgent,
      language: navigator.language,
      cookieEnabled: navigator.cookieEnabled,
    },
    
    // 性能信息
    performance: {
      memory: performance.memory,
      timing: performance.timing,
    },
  };
  
  return debugInfo;
}
```

### 错误报告生成
```typescript
// 生成错误报告
function generateErrorReport(error: Error) {
  const report = {
    timestamp: new Date().toISOString(),
    error: {
      message: error.message,
      stack: error.stack,
      name: error.name,
    },
    context: {
      url: window.location.href,
      userAgent: navigator.userAgent,
      // 添加更多上下文信息
    },
    logs: getRecentLogs(), // 获取最近的日志
  };
  
  console.error('📋 错误报告:', report);
  
  // 可选：发送到错误收集服务
  // sendErrorReport(report);
  
  return report;
}
```

## 🔍 网络调试

### HTTP 请求调试
```typescript
// 拦截和调试 HTTP 请求
const originalFetch = window.fetch;
window.fetch = async function(input, init) {
  console.log('🌐 发送请求:', input, init);
  
  try {
    const response = await originalFetch(input, init);
    console.log('📡 收到响应:', response.status, response.statusText);
    return response;
  } catch (error) {
    console.error('❌ 请求失败:', error);
    throw error;
  }
};
```

### Tauri 命令调试
```typescript
// 包装 Tauri invoke 函数进行调试
const originalInvoke = invoke;
window.invoke = async function(command: string, args?: any) {
  console.log(`🔧 调用命令: ${command}`, args);
  
  try {
    const result = await originalInvoke(command, args);
    console.log(`✅ 命令成功: ${command}`, result);
    return result;
  } catch (error) {
    console.error(`❌ 命令失败: ${command}`, error);
    throw error;
  }
};
```

## 📝 调试最佳实践

### 1. 日志级别使用
```rust
// 合理使用日志级别
trace!("详细的执行流程信息");    // 开发调试
debug!("调试信息");             // 开发调试
info!("一般信息");              // 生产环境
warn!("警告信息");              // 生产环境
error!("错误信息");             // 生产环境
```

### 2. 结构化日志
```typescript
// 使用结构化日志
const logger = {
  debug: (message: string, data?: any) => {
    console.log(`[DEBUG] ${new Date().toISOString()} ${message}`, data);
  },
  info: (message: string, data?: any) => {
    console.log(`[INFO] ${new Date().toISOString()} ${message}`, data);
  },
  error: (message: string, error?: Error) => {
    console.error(`[ERROR] ${new Date().toISOString()} ${message}`, error);
  },
};
```

### 3. 调试开关
```typescript
// 使用环境变量控制调试
const DEBUG = import.meta.env.DEV;

function debugLog(message: string, data?: any) {
  if (DEBUG) {
    console.log(`[DEBUG] ${message}`, data);
  }
}
```

### 4. 错误边界
```vue
<!-- Vue 错误边界组件 -->
<template>
  <div v-if="error" class="error-boundary">
    <h2>出现错误</h2>
    <p>{{ error.message }}</p>
    <button @click="retry">重试</button>
  </div>
  <slot v-else />
</template>

<script setup>
import { ref, onErrorCaptured } from 'vue'

const error = ref(null)

onErrorCaptured((err) => {
  error.value = err
  console.error('组件错误:', err)
  return false
})

function retry() {
  error.value = null
}
</script>
```

通过这些调试方法和工具，可以有效地定位和解决开发过程中遇到的问题，提高开发效率和代码质量。