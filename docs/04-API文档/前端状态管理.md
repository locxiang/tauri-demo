# å‰ç«¯çŠ¶æ€ç®¡ç†

## ğŸ“‹ æ¦‚è¿°

å‰ç«¯çŠ¶æ€ç®¡ç†é‡‡ç”¨ **Pinia** ä½œä¸ºæ ¸å¿ƒçŠ¶æ€ç®¡ç†åº“ï¼Œé…åˆ **Vue 3 Composition API** å®ç°å“åº”å¼çš„çŠ¶æ€ç®¡ç†ã€‚æ•´ä¸ªçŠ¶æ€å±‚é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼Œæ¯ä¸ªä¸šåŠ¡é¢†åŸŸéƒ½æœ‰ç‹¬ç«‹çš„ Storeï¼Œç¡®ä¿å…³æ³¨ç‚¹åˆ†ç¦»å’Œä»£ç å¯ç»´æŠ¤æ€§ã€‚

## ğŸ—ï¸ çŠ¶æ€ç®¡ç†æ¶æ„

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Vue 3 ç»„ä»¶å±‚                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Dashboard  â”‚ SystemLogs â”‚ ProxyController â”‚ SystemPerms â”‚  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Pinia Store å±‚                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚AppStore â”‚ â”‚LogStore â”‚ â”‚AuthStoreâ”‚ â”‚ProxyStr â”‚ â”‚ Others  â”‚ â”‚
â”‚ â”‚åº”ç”¨çŠ¶æ€ â”‚ â”‚æ—¥å¿—çŠ¶æ€ â”‚ â”‚è®¤è¯çŠ¶æ€ â”‚ â”‚æŠ“åŒ…çŠ¶æ€ â”‚ â”‚  ...    â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Tauri IPC å±‚                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              Rust åç«¯ API å‘½ä»¤                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ¨¡å—åŒ–è®¾è®¡

```typescript
// stores/index.ts - ç»Ÿä¸€å¯¼å‡º
export { useAppStore } from './appStore';
export { useLogStore } from './logStore';
export { useAuthStore } from './authStore';
export { useProxyStore } from './proxyStore';

// ç±»å‹å¯¼å‡º
export type { AppState } from './appStore';
export type { LogEntry, LogFilters, LogStats } from './logStore';
export type { TokenStatus, TokenEvent } from './authStore';
export type { PacketData, CaptureStatus } from './proxyStore';
```

## ğŸ“± AppStore - åº”ç”¨çŠ¶æ€ç®¡ç†

### çŠ¶æ€å®šä¹‰

```typescript
interface AppState {
  // åŸºç¡€ä¿¡æ¯
  debug: boolean;                    // è°ƒè¯•æ¨¡å¼
  version: string;                   // åº”ç”¨ç‰ˆæœ¬
  isInitialized: boolean;            // åˆå§‹åŒ–çŠ¶æ€
  
  // è¿è¡Œæ—¶çŠ¶æ€
  startTime: number;                 // å¯åŠ¨æ—¶é—´æˆ³
  currentUptime: number;             // å½“å‰è¿è¡Œæ—¶é•¿
  
  // ç³»ç»Ÿä¿¡æ¯
  platform: string;                 // è¿è¡Œå¹³å°
  tauri_version: string;             // Tauriç‰ˆæœ¬
  
  // UIçŠ¶æ€
  currentTheme: 'light' | 'dark';    // ä¸»é¢˜æ¨¡å¼
  sidebarCollapsed: boolean;         // ä¾§è¾¹æ æŠ˜å çŠ¶æ€
}
```

### Storeå®ç°

```typescript
export const useAppStore = defineStore('app', () => {
  // çŠ¶æ€å®šä¹‰
  const debug = ref(false);
  const version = ref('0.7.0');
  const isInitialized = ref(false);
  const startTime = ref(0);
  const currentUptime = ref(0);
  const platform = ref('');
  const tauri_version = ref('');
  const currentTheme = ref<'light' | 'dark'>('dark');
  const sidebarCollapsed = ref(false);

  // è®¡ç®—å±æ€§
  const uptime = computed(() => {
    const seconds = Math.floor(currentUptime.value / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    
    if (hours > 0) {
      return `${hours}å°æ—¶${minutes % 60}åˆ†é’Ÿ`;
    } else if (minutes > 0) {
      return `${minutes}åˆ†é’Ÿ${seconds % 60}ç§’`;
    } else {
      return `${seconds}ç§’`;
    }
  });

  const isDebugMode = computed(() => debug.value);

  // åŠ¨ä½œæ–¹æ³•
  const initialize = async (): Promise<void> => {
    try {
      console.log('ğŸš€ åˆå§‹åŒ–åº”ç”¨çŠ¶æ€...');
      
      // è®¾ç½®å¯åŠ¨æ—¶é—´
      startTime.value = Date.now();
      
      // è·å–ç³»ç»Ÿä¿¡æ¯
      const systemInfo = await invoke<SystemInfo>('get_system_info');
      platform.value = systemInfo.platform;
      tauri_version.value = systemInfo.tauri_version;
      
      // å¯åŠ¨å®šæ—¶å™¨æ›´æ–°è¿è¡Œæ—¶é—´
      startUptimeTimer();
      
      // æ ‡è®°ä¸ºå·²åˆå§‹åŒ–
      isInitialized.value = true;
      
      console.log('âœ… åº”ç”¨çŠ¶æ€åˆå§‹åŒ–å®Œæˆ');
    } catch (error) {
      console.error('âŒ åº”ç”¨çŠ¶æ€åˆå§‹åŒ–å¤±è´¥:', error);
      throw error;
    }
  };

  const updateUptime = (): void => {
    if (startTime.value > 0) {
      currentUptime.value = Date.now() - startTime.value;
    }
  };

  const startUptimeTimer = (): void => {
    setInterval(updateUptime, 1000); // æ¯ç§’æ›´æ–°ä¸€æ¬¡
  };

  const toggleTheme = (): void => {
    currentTheme.value = currentTheme.value === 'light' ? 'dark' : 'light';
    // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ä¸»é¢˜åˆ‡æ¢çš„å…·ä½“é€»è¾‘
  };

  const toggleSidebar = (): void => {
    sidebarCollapsed.value = !sidebarCollapsed.value;
  };

  const setDebugMode = (enabled: boolean): void => {
    debug.value = enabled;
    console.log(`ğŸ› è°ƒè¯•æ¨¡å¼: ${enabled ? 'å¼€å¯' : 'å…³é—­'}`);
  };

  // è¿”å›å“åº”å¼çŠ¶æ€å’Œæ–¹æ³•
  return {
    // çŠ¶æ€
    debug: readonly(debug),
    version: readonly(version),
    isInitialized: readonly(isInitialized),
    startTime: readonly(startTime),
    currentUptime: readonly(currentUptime),
    platform: readonly(platform),
    tauri_version: readonly(tauri_version),
    currentTheme,
    sidebarCollapsed,
    
    // è®¡ç®—å±æ€§
    uptime,
    isDebugMode,
    
    // æ–¹æ³•
    initialize,
    updateUptime,
    toggleTheme,
    toggleSidebar,
    setDebugMode
  };
});
```

## ğŸ“‹ LogStore - æ—¥å¿—çŠ¶æ€ç®¡ç†

### çŠ¶æ€å®šä¹‰

```typescript
interface LogState {
  // æ—¥å¿—æ•°æ®
  logs: LogEntry[];                  // æ—¥å¿—åˆ—è¡¨
  filteredLogs: LogEntry[];          // è¿‡æ»¤åçš„æ—¥å¿—
  
  // æ§åˆ¶çŠ¶æ€
  isStreaming: boolean;              // æ˜¯å¦æ­£åœ¨å®æ—¶æµ
  isLoading: boolean;                // æ˜¯å¦æ­£åœ¨åŠ è½½
  autoScroll: boolean;               // è‡ªåŠ¨æ»šåŠ¨å¼€å…³
  
  // è¿‡æ»¤å’Œé…ç½®
  currentFilters: LogFilters;        // å½“å‰è¿‡æ»¤æ¡ä»¶
  maxLogEntries: number;             // æœ€å¤§æ˜¾ç¤ºæ¡ç›®æ•°
  
  // ç»Ÿè®¡ä¿¡æ¯
  stats: LogStats;                   // æ—¥å¿—ç»Ÿè®¡
  lastUpdateTime: string;            // æœ€åæ›´æ–°æ—¶é—´
  error: string | null;              // é”™è¯¯ä¿¡æ¯
}
```

### Storeå®ç°

```typescript
export const useLogStore = defineStore('log', () => {
  // çŠ¶æ€å®šä¹‰
  const logs = ref<LogEntry[]>([]);
  const isStreaming = ref(false);
  const isLoading = ref(false);
  const currentFilters = ref<LogFilters>({});
  const stats = ref<LogStats>({
    total_logs: 0,
    error_count: 0,
    warn_count: 0,
    info_count: 0,
    debug_count: 0,
    trace_count: 0
  });
  const maxLogEntries = ref(1000);
  const lastUpdateTime = ref('');
  const error = ref<string | null>(null);

  // äº‹ä»¶ç›‘å¬å™¨
  let logStreamListener: any = null;

  // è®¡ç®—å±æ€§
  const filteredLogs = computed(() => {
    let filtered = logs.value;

    // æŒ‰æ—¥å¿—çº§åˆ«è¿‡æ»¤
    if (currentFilters.value.level) {
      filtered = filtered.filter(log => log.level === currentFilters.value.level);
    }

    // æŒ‰å…³é”®è¯è¿‡æ»¤
    if (currentFilters.value.keywords && currentFilters.value.keywords.length > 0) {
      filtered = filtered.filter(log => 
        currentFilters.value.keywords!.some(keyword => 
          log.message.toLowerCase().includes(keyword.toLowerCase()) ||
          log.target.toLowerCase().includes(keyword.toLowerCase())
        )
      );
    }

    return filtered.sort((a, b) => a.timestamp - b.timestamp);
  });

  const logLevelCounts = computed(() => {
    const counts = {
      error: 0,
      warn: 0,
      info: 0,
      debug: 0,
      trace: 0
    };

    logs.value.forEach(log => {
      if (log.level in counts) {
        counts[log.level as keyof typeof counts]++;
      }
    });

    return counts;
  });

  // åŠ¨ä½œæ–¹æ³•
  const loadRecentLogs = async (limit: number = 1000): Promise<void> => {
    isLoading.value = true;
    error.value = null;
    
    try {
      console.log('ğŸ”„ åŠ è½½æœ€è¿‘çš„æ—¥å¿—...');
      const recentLogs = await invoke<LogEntry[]>('get_recent_logs', { 
        limit, 
        filters: Object.keys(currentFilters.value).length > 0 
          ? currentFilters.value 
          : null 
      });
      
      logs.value = recentLogs;
      lastUpdateTime.value = new Date().toLocaleTimeString();
      
      console.log(`âœ… æˆåŠŸåŠ è½½ ${recentLogs.length} æ¡æ—¥å¿—`);
    } catch (err) {
      console.error('âŒ åŠ è½½æ—¥å¿—å¤±è´¥:', err);
      error.value = `åŠ è½½æ—¥å¿—å¤±è´¥: ${err}`;
    } finally {
      isLoading.value = false;
    }
  };

  const startLogStream = async (): Promise<void> => {
    if (isStreaming.value) return;

    try {
      console.log('ğŸš€ å¼€å§‹è®¢é˜…æ—¥å¿—æµ...');
      
      // è®¢é˜…åç«¯æ—¥å¿—æµ
      await invoke('subscribe_log_stream', { 
        filters: Object.keys(currentFilters.value).length > 0 
          ? currentFilters.value 
          : null 
      });

      // ç›‘å¬æ—¥å¿—æµäº‹ä»¶
      logStreamListener = await listen<LogEntry>('log-stream', (event) => {
        const newLog = event.payload;
        
        // æ·»åŠ æ–°æ—¥å¿—åˆ°å‰ç«¯
        logs.value.push(newLog);
        
        // ä¿æŒæœ€å¤§æ•°é‡é™åˆ¶
        if (logs.value.length > maxLogEntries.value) {
          logs.value = logs.value.slice(-maxLogEntries.value);
        }
        
        // æ›´æ–°æœ€åæ›´æ–°æ—¶é—´
        lastUpdateTime.value = new Date().toLocaleTimeString();
      });

      isStreaming.value = true;
      console.log('âœ… æ—¥å¿—æµè®¢é˜…æˆåŠŸ');
    } catch (err) {
      console.error('âŒ è®¢é˜…æ—¥å¿—æµå¤±è´¥:', err);
      error.value = `è®¢é˜…æ—¥å¿—æµå¤±è´¥: ${err}`;
    }
  };

  const stopLogStream = async (): Promise<void> => {
    if (!isStreaming.value) return;

    try {
      console.log('ğŸ›‘ åœæ­¢æ—¥å¿—æµè®¢é˜…...');
      
      // å–æ¶ˆè®¢é˜…åç«¯æ—¥å¿—æµ
      await invoke('unsubscribe_log_stream');
      
      // å–æ¶ˆå‰ç«¯äº‹ä»¶ç›‘å¬
      if (logStreamListener) {
        logStreamListener();
        logStreamListener = null;
      }
      
      isStreaming.value = false;
      console.log('âœ… æ—¥å¿—æµè®¢é˜…å·²åœæ­¢');
    } catch (err) {
      console.error('âŒ åœæ­¢æ—¥å¿—æµå¤±è´¥:', err);
      error.value = `åœæ­¢æ—¥å¿—æµå¤±è´¥: ${err}`;
    }
  };

  const clearLogs = async (): Promise<void> => {
    try {
      console.log('ğŸ—‘ï¸ æ¸…ç©ºæ—¥å¿—...');
      
      // æ¸…ç©ºåç«¯æ—¥å¿—ç¼“å†²åŒº
      await invoke('clear_logs');
      
      // æ¸…ç©ºå‰ç«¯æ—¥å¿—
      logs.value = [];
      lastUpdateTime.value = new Date().toLocaleTimeString();
      
      console.log('âœ… æ—¥å¿—å·²æ¸…ç©º');
    } catch (err) {
      console.error('âŒ æ¸…ç©ºæ—¥å¿—å¤±è´¥:', err);
      error.value = `æ¸…ç©ºæ—¥å¿—å¤±è´¥: ${err}`;
    }
  };

  const updateFilters = (filters: LogFilters): void => {
    currentFilters.value = { ...filters };
    console.log('ğŸ” æ›´æ–°æ—¥å¿—è¿‡æ»¤å™¨:', filters);
  };

  const getLogStats = async (): Promise<LogStats | null> => {
    try {
      const logStats = await invoke<LogStats>('get_log_stats');
      stats.value = logStats;
      return logStats;
    } catch (err) {
      console.error('âŒ è·å–æ—¥å¿—ç»Ÿè®¡å¤±è´¥:', err);
      error.value = `è·å–æ—¥å¿—ç»Ÿè®¡å¤±è´¥: ${err}`;
      return null;
    }
  };

  const cleanup = async (): Promise<void> => {
    if (isStreaming.value) {
      await stopLogStream();
    }
  };

  return {
    // çŠ¶æ€
    logs: readonly(logs),
    isStreaming: readonly(isStreaming),
    isLoading: readonly(isLoading),
    currentFilters: readonly(currentFilters),
    stats: readonly(stats),
    maxLogEntries,
    lastUpdateTime: readonly(lastUpdateTime),
    error: readonly(error),

    // è®¡ç®—å±æ€§
    filteredLogs,
    logLevelCounts,

    // æ–¹æ³•
    loadRecentLogs,
    startLogStream,
    stopLogStream,
    clearLogs,
    updateFilters,
    getLogStats,
    cleanup
  };
});
```

## ğŸ” AuthStore - è®¤è¯çŠ¶æ€ç®¡ç†

### çŠ¶æ€å®šä¹‰

```typescript
interface AuthState {
  // TokençŠ¶æ€
  tokenStatus: TokenStatus[];        // æ‰€æœ‰ç³»ç»Ÿçš„TokençŠ¶æ€
  tokenEvents: TokenEvent[];         // Tokenäº‹ä»¶å†å²
  
  // ç³»ç»Ÿç»Ÿè®¡
  systemStats: {
    total_systems: number;           // æ€»ç³»ç»Ÿæ•°
    systems_with_token: number;      // æœ‰Tokençš„ç³»ç»Ÿæ•°
    expired_tokens: number;          // è¿‡æœŸTokenæ•°
  };
  
  // æ§åˆ¶çŠ¶æ€
  isLoading: boolean;                // åŠ è½½çŠ¶æ€
  lastRefreshTime: string;           // æœ€ååˆ·æ–°æ—¶é—´
  autoRefresh: boolean;              // è‡ªåŠ¨åˆ·æ–°å¼€å…³
  refreshInterval: number;           // åˆ·æ–°é—´éš”(æ¯«ç§’)
}
```

### Storeå®ç°

```typescript
export const useAuthStore = defineStore('auth', () => {
  // çŠ¶æ€å®šä¹‰
  const tokenStatus = ref<TokenStatus[]>([]);
  const tokenEvents = ref<TokenEvent[]>([]);
  const systemStats = ref({
    total_systems: 0,
    systems_with_token: 0,
    expired_tokens: 0
  });
  const isLoading = ref(false);
  const lastRefreshTime = ref('');
  const autoRefresh = ref(true);
  const refreshInterval = ref(5000); // 5ç§’

  // å®šæ—¶å™¨
  let refreshTimer: number | null = null;
  let tokenEventListener: any = null;

  // è®¡ç®—å±æ€§
  const systemsWithToken = computed(() => 
    tokenStatus.value.filter(status => status.has_token)
  );

  const expiredSystems = computed(() => 
    tokenStatus.value.filter(status => status.is_expired)
  );

  const healthySystems = computed(() => 
    tokenStatus.value.filter(status => status.has_token && !status.is_expired)
  );

  // åŠ¨ä½œæ–¹æ³•
  const initialize = async (): Promise<void> => {
    try {
      console.log('ğŸ” åˆå§‹åŒ–è®¤è¯çŠ¶æ€ç®¡ç†...');
      
      // è®¾ç½®Tokenäº‹ä»¶ç›‘å¬
      await setupTokenEventListener();
      
      // åˆå§‹åŠ è½½TokençŠ¶æ€
      await refreshTokenStatus();
      
      // å¯åŠ¨è‡ªåŠ¨åˆ·æ–°
      if (autoRefresh.value) {
        startAutoRefresh();
      }
      
      console.log('âœ… è®¤è¯çŠ¶æ€ç®¡ç†åˆå§‹åŒ–å®Œæˆ');
    } catch (error) {
      console.error('âŒ è®¤è¯çŠ¶æ€ç®¡ç†åˆå§‹åŒ–å¤±è´¥:', error);
      throw error;
    }
  };

  const refreshTokenStatus = async (): Promise<void> => {
    isLoading.value = true;
    
    try {
      console.log('ğŸ”„ åˆ·æ–°TokençŠ¶æ€...');
      
      // è·å–æ‰€æœ‰ç³»ç»Ÿçš„TokençŠ¶æ€
      const statuses = await invoke<TokenStatus[]>('get_all_token_status');
      tokenStatus.value = statuses;
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      updateSystemStats();
      
      // æ›´æ–°æœ€ååˆ·æ–°æ—¶é—´
      lastRefreshTime.value = new Date().toLocaleTimeString();
      
      console.log(`âœ… åˆ·æ–°å®Œæˆï¼Œå…± ${statuses.length} ä¸ªç³»ç»Ÿ`);
    } catch (error) {
      console.error('âŒ åˆ·æ–°TokençŠ¶æ€å¤±è´¥:', error);
    } finally {
      isLoading.value = false;
    }
  };

  const clearSystemToken = async (systemId: string): Promise<void> => {
    try {
      console.log(`ğŸ—‘ï¸ æ¸…é™¤ç³»ç»Ÿ ${systemId} çš„Token...`);
      
      await invoke('clear_system_token', { system_id: systemId });
      
      // åˆ·æ–°çŠ¶æ€
      await refreshTokenStatus();
      
      console.log(`âœ… ç³»ç»Ÿ ${systemId} çš„Tokenå·²æ¸…é™¤`);
    } catch (error) {
      console.error(`âŒ æ¸…é™¤ç³»ç»Ÿ ${systemId} Tokenå¤±è´¥:`, error);
    }
  };

  const clearAllTokens = async (): Promise<void> => {
    try {
      console.log('ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰Token...');
      
      await invoke('clear_all_tokens');
      
      // åˆ·æ–°çŠ¶æ€
      await refreshTokenStatus();
      
      console.log('âœ… æ‰€æœ‰Tokenå·²æ¸…é™¤');
    } catch (error) {
      console.error('âŒ æ¸…é™¤æ‰€æœ‰Tokenå¤±è´¥:', error);
    }
  };

  const setupTokenEventListener = async (): Promise<void> => {
    try {
      // è®¾ç½®Tokenäº‹ä»¶é€šé“
      await invoke('set_token_event_channel');
      
      // ç›‘å¬Tokenäº‹ä»¶
      tokenEventListener = await listen<TokenEvent>('token-event', (event) => {
        const tokenEvent = event.payload;
        
        // æ·»åŠ åˆ°äº‹ä»¶å†å²
        tokenEvents.value.unshift(tokenEvent);
        
        // ä¿æŒæœ€å¤§äº‹ä»¶æ•°é‡
        if (tokenEvents.value.length > 100) {
          tokenEvents.value = tokenEvents.value.slice(0, 100);
        }
        
        console.log('ğŸ“¨ æ”¶åˆ°Tokenäº‹ä»¶:', tokenEvent);
        
        // åˆ·æ–°TokençŠ¶æ€
        refreshTokenStatus();
      });
      
      console.log('âœ… Tokenäº‹ä»¶ç›‘å¬å™¨è®¾ç½®æˆåŠŸ');
    } catch (error) {
      console.error('âŒ è®¾ç½®Tokenäº‹ä»¶ç›‘å¬å™¨å¤±è´¥:', error);
    }
  };

  const updateSystemStats = (): void => {
    systemStats.value = {
      total_systems: tokenStatus.value.length,
      systems_with_token: systemsWithToken.value.length,
      expired_tokens: expiredSystems.value.length
    };
  };

  const startAutoRefresh = (): void => {
    if (refreshTimer) return;
    
    refreshTimer = window.setInterval(() => {
      if (autoRefresh.value) {
        refreshTokenStatus();
      }
    }, refreshInterval.value);
    
    console.log(`ğŸ”„ å¯åŠ¨è‡ªåŠ¨åˆ·æ–°ï¼Œé—´éš” ${refreshInterval.value}ms`);
  };

  const stopAutoRefresh = (): void => {
    if (refreshTimer) {
      clearInterval(refreshTimer);
      refreshTimer = null;
      console.log('ğŸ›‘ åœæ­¢è‡ªåŠ¨åˆ·æ–°');
    }
  };

  const setAutoRefresh = (enabled: boolean): void => {
    autoRefresh.value = enabled;
    
    if (enabled) {
      startAutoRefresh();
    } else {
      stopAutoRefresh();
    }
  };

  const cleanup = async (): Promise<void> => {
    // åœæ­¢è‡ªåŠ¨åˆ·æ–°
    stopAutoRefresh();
    
    // å–æ¶ˆäº‹ä»¶ç›‘å¬
    if (tokenEventListener) {
      tokenEventListener();
      tokenEventListener = null;
    }
  };

  return {
    // çŠ¶æ€
    tokenStatus: readonly(tokenStatus),
    tokenEvents: readonly(tokenEvents),
    systemStats: readonly(systemStats),
    isLoading: readonly(isLoading),
    lastRefreshTime: readonly(lastRefreshTime),
    autoRefresh,
    refreshInterval,
    
    // è®¡ç®—å±æ€§
    systemsWithToken,
    expiredSystems,
    healthySystems,
    
    // æ–¹æ³•
    initialize,
    refreshTokenStatus,
    clearSystemToken,
    clearAllTokens,
    setAutoRefresh,
    cleanup
  };
});
```

## ğŸ“¡ ProxyStore - æŠ“åŒ…çŠ¶æ€ç®¡ç†

### çŠ¶æ€å®šä¹‰

```typescript
interface ProxyState {
  // æ•è·çŠ¶æ€
  captureStatus: CaptureStatus | null;    // å½“å‰æ•è·çŠ¶æ€
  isCapturing: boolean;                   // æ˜¯å¦æ­£åœ¨æ•è·
  
  // æ•°æ®åŒ…ç®¡ç†
  packets: PacketData[];                  // æ•°æ®åŒ…åˆ—è¡¨
  filteredPackets: PacketData[];          // è¿‡æ»¤åçš„æ•°æ®åŒ…
  
  // ç½‘ç»œè®¾å¤‡
  networkDevices: NetworkDevice[];        // å¯ç”¨ç½‘ç»œè®¾å¤‡
  selectedDevice: string | null;          // é€‰ä¸­çš„è®¾å¤‡
  
  // è¿‡æ»¤å™¨
  packetFilters: PacketFilters;           // æ•°æ®åŒ…è¿‡æ»¤å™¨
  
  // HTTPè¯·æ±‚
  httpRequests: HttpRequest[];            // HTTPè¯·æ±‚åˆ—è¡¨
  
  // ç»Ÿè®¡ä¿¡æ¯
  statistics: CaptureStatistics;          // æ•è·ç»Ÿè®¡
}
```

### Storeå®ç°è¦ç‚¹

```typescript
export const useProxyStore = defineStore('proxy', () => {
  // æ ¸å¿ƒæ–¹æ³•
  const startCapture = async (deviceName: string): Promise<void> => {
    try {
      console.log(`ğŸš€ å¼€å§‹åœ¨è®¾å¤‡ ${deviceName} ä¸Šæ•è·...`);
      
      // è®¾ç½®äº‹ä»¶é€šé“
      await invoke('set_status_channel');
      await invoke('set_http_channel');
      
      // å¼€å§‹æ•è·
      await invoke('init_capture', { device_name: deviceName });
      
      // è®¾ç½®äº‹ä»¶ç›‘å¬
      await setupEventListeners();
      
      selectedDevice.value = deviceName;
      console.log('âœ… æ•è·å·²å¯åŠ¨');
    } catch (error) {
      console.error('âŒ å¯åŠ¨æ•è·å¤±è´¥:', error);
      throw error;
    }
  };

  const stopCapture = async (): Promise<void> => {
    try {
      console.log('ğŸ›‘ åœæ­¢æ•è·...');
      
      await invoke('stop_capture');
      
      // æ¸…ç†äº‹ä»¶ç›‘å¬
      cleanupEventListeners();
      
      selectedDevice.value = null;
      console.log('âœ… æ•è·å·²åœæ­¢');
    } catch (error) {
      console.error('âŒ åœæ­¢æ•è·å¤±è´¥:', error);
    }
  };
});
```

## ğŸ”§ çŠ¶æ€ç®¡ç†æœ€ä½³å®è·µ

### 1. åˆå§‹åŒ–é¡ºåº

```typescript
// åœ¨ App.vue ä¸­çš„åˆå§‹åŒ–é¡ºåº
onMounted(async () => {
  try {
    // 1. é¦–å…ˆåˆå§‹åŒ–åº”ç”¨çŠ¶æ€
    await appStore.initialize();
    
    // 2. å¹¶è¡Œåˆå§‹åŒ–å…¶ä»–çŠ¶æ€
    await Promise.all([
      logStore.loadRecentLogs(),
      authStore.initialize(),
      proxyStore.initialize()
    ]);
    
    console.log('âœ… æ‰€æœ‰çŠ¶æ€ç®¡ç†åˆå§‹åŒ–å®Œæˆ');
  } catch (error) {
    console.error('âŒ çŠ¶æ€ç®¡ç†åˆå§‹åŒ–å¤±è´¥:', error);
  }
});
```

### 2. é”™è¯¯å¤„ç†æ¨¡å¼

```typescript
// ç»Ÿä¸€çš„é”™è¯¯å¤„ç†
const handleAsyncAction = async (
  action: () => Promise<void>,
  errorMessage: string
): Promise<void> => {
  try {
    await action();
  } catch (error) {
    console.error(errorMessage, error);
    // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ å…¨å±€é”™è¯¯é€šçŸ¥
    throw error;
  }
};
```

### 3. ç±»å‹å®‰å…¨ä¿éšœ

```typescript
// ä¸¥æ ¼çš„ç±»å‹å®šä¹‰
interface StoreState {
  [key: string]: unknown;
}

interface StoreActions {
  [key: string]: (...args: any[]) => any;
}

// ç±»å‹å®ˆå«
const isValidLogEntry = (obj: unknown): obj is LogEntry => {
  return typeof obj === 'object' && 
         obj !== null && 
         'id' in obj && 
         'timestamp' in obj && 
         'level' in obj;
};
```

### 4. æ€§èƒ½ä¼˜åŒ–

```typescript
// ä½¿ç”¨è®¡ç®—å±æ€§è¿›è¡Œæ•°æ®è¿‡æ»¤
const filteredData = computed(() => {
  return data.value.filter(item => filter.value(item));
});

// é˜²æŠ–å¤„ç†é¢‘ç¹æ›´æ–°
import { debounce } from 'lodash-es';

const debouncedUpdate = debounce((value: string) => {
  searchKeyword.value = value;
}, 300);
```

## ğŸ“Š çŠ¶æ€æŒä¹…åŒ–

### localStorageé›†æˆ

```typescript
// æŒä¹…åŒ–é…ç½®
const persistentState = {
  currentTheme: 'currentTheme',
  sidebarCollapsed: 'sidebarCollapsed',
  autoRefresh: 'autoRefresh',
  maxLogEntries: 'maxLogEntries'
};

// è‡ªåŠ¨ä¿å­˜åˆ°localStorage
watch(currentTheme, (newTheme) => {
  localStorage.setItem(persistentState.currentTheme, newTheme);
});

// ä»localStorageæ¢å¤
const restoreFromStorage = (): void => {
  const savedTheme = localStorage.getItem(persistentState.currentTheme);
  if (savedTheme) {
    currentTheme.value = savedTheme as 'light' | 'dark';
  }
};
```

## ğŸ§ª æµ‹è¯•æ”¯æŒ

### Storeæµ‹è¯•ç¤ºä¾‹

```typescript
// æµ‹è¯•è®¾ç½®
import { createPinia, setActivePinia } from 'pinia';
import { useLogStore } from '@/stores/logStore';

describe('LogStore', () => {
  beforeEach(() => {
    setActivePinia(createPinia());
  });

  it('åº”è¯¥æ­£ç¡®åˆå§‹åŒ–çŠ¶æ€', () => {
    const logStore = useLogStore();
    
    expect(logStore.logs).toEqual([]);
    expect(logStore.isStreaming).toBe(false);
    expect(logStore.isLoading).toBe(false);
  });

  it('åº”è¯¥æ­£ç¡®è¿‡æ»¤æ—¥å¿—', async () => {
    const logStore = useLogStore();
    
    // è®¾ç½®æµ‹è¯•æ•°æ®
    logStore.logs = mockLogEntries;
    logStore.updateFilters({ level: 'error' });
    
    // éªŒè¯è¿‡æ»¤ç»“æœ
    expect(logStore.filteredLogs).toHaveLength(2);
  });
});
```

è¿™å¥—çŠ¶æ€ç®¡ç†æ¶æ„æä¾›äº†ï¼š
- ğŸ”„ **å“åº”å¼æ›´æ–°**: Vue 3çš„å“åº”å¼ç³»ç»Ÿç¡®ä¿UIå®æ—¶æ›´æ–°
- ğŸ—ï¸ **æ¨¡å—åŒ–è®¾è®¡**: æ¯ä¸ªä¸šåŠ¡é¢†åŸŸç‹¬ç«‹çš„Store
- ğŸ›¡ï¸ **ç±»å‹å®‰å…¨**: TypeScriptæä¾›å®Œæ•´çš„ç±»å‹ä¿éšœ
- âš¡ **æ€§èƒ½ä¼˜åŒ–**: è®¡ç®—å±æ€§å’Œé˜²æŠ–å¤„ç†
- ğŸ§ª **æ˜“äºæµ‹è¯•**: æ¸…æ™°çš„çŠ¶æ€å’ŒåŠ¨ä½œåˆ†ç¦»

é€šè¿‡è¿™å¥—çŠ¶æ€ç®¡ç†ç³»ç»Ÿï¼Œå‰ç«¯èƒ½å¤Ÿé«˜æ•ˆåœ°ç®¡ç†å¤æ‚çš„åº”ç”¨çŠ¶æ€ï¼Œç¡®ä¿æ•°æ®æµçš„ä¸€è‡´æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚