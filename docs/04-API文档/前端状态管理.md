# 前端状态管理

## 📋 概述

前端状态管理采用 **Pinia** 作为核心状态管理库，配合 **Vue 3 Composition API** 实现响应式的状态管理。整个状态层采用模块化设计，每个业务领域都有独立的 Store，确保关注点分离和代码可维护性。

## 🏗️ 状态管理架构

### 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    Vue 3 组件层                             │
├─────────────────────────────────────────────────────────────┤
│  Dashboard  │ SystemLogs │ ProxyController │ SystemPerms │  │
├─────────────────────────────────────────────────────────────┤
│                   Pinia Store 层                           │
├─────────────────────────────────────────────────────────────┤
│ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ │
│ │AppStore │ │LogStore │ │AuthStore│ │ProxyStr │ │ Others  │ │
│ │应用状态 │ │日志状态 │ │认证状态 │ │抓包状态 │ │  ...    │ │
│ └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘ │
├─────────────────────────────────────────────────────────────┤
│                   Tauri IPC 层                             │
├─────────────────────────────────────────────────────────────┤
│              Rust 后端 API 命令                             │
└─────────────────────────────────────────────────────────────┘
```

### 模块化设计

```typescript
// stores/index.ts - 统一导出
export { useAppStore } from './appStore';
export { useLogStore } from './logStore';
export { useAuthStore } from './authStore';
export { useProxyStore } from './proxyStore';

// 类型导出
export type { AppState } from './appStore';
export type { LogEntry, LogFilters, LogStats } from './logStore';
export type { TokenStatus, TokenEvent } from './authStore';
export type { PacketData, CaptureStatus } from './proxyStore';
```

## 📱 AppStore - 应用状态管理

### 状态定义

```typescript
interface AppState {
  // 基础信息
  debug: boolean;                    // 调试模式
  version: string;                   // 应用版本
  isInitialized: boolean;            // 初始化状态
  
  // 运行时状态
  startTime: number;                 // 启动时间戳
  currentUptime: number;             // 当前运行时长
  
  // 系统信息
  platform: string;                 // 运行平台
  tauri_version: string;             // Tauri版本
  
  // UI状态
  currentTheme: 'light' | 'dark';    // 主题模式
  sidebarCollapsed: boolean;         // 侧边栏折叠状态
}
```

### Store实现

```typescript
export const useAppStore = defineStore('app', () => {
  // 状态定义
  const debug = ref(false);
  const version = ref('0.7.0');
  const isInitialized = ref(false);
  const startTime = ref(0);
  const currentUptime = ref(0);
  const platform = ref('');
  const tauri_version = ref('');
  const currentTheme = ref<'light' | 'dark'>('dark');
  const sidebarCollapsed = ref(false);

  // 计算属性
  const uptime = computed(() => {
    const seconds = Math.floor(currentUptime.value / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    
    if (hours > 0) {
      return `${hours}小时${minutes % 60}分钟`;
    } else if (minutes > 0) {
      return `${minutes}分钟${seconds % 60}秒`;
    } else {
      return `${seconds}秒`;
    }
  });

  const isDebugMode = computed(() => debug.value);

  // 动作方法
  const initialize = async (): Promise<void> => {
    try {
      console.log('🚀 初始化应用状态...');
      
      // 设置启动时间
      startTime.value = Date.now();
      
      // 获取系统信息
      const systemInfo = await invoke<SystemInfo>('get_system_info');
      platform.value = systemInfo.platform;
      tauri_version.value = systemInfo.tauri_version;
      
      // 启动定时器更新运行时间
      startUptimeTimer();
      
      // 标记为已初始化
      isInitialized.value = true;
      
      console.log('✅ 应用状态初始化完成');
    } catch (error) {
      console.error('❌ 应用状态初始化失败:', error);
      throw error;
    }
  };

  const updateUptime = (): void => {
    if (startTime.value > 0) {
      currentUptime.value = Date.now() - startTime.value;
    }
  };

  const startUptimeTimer = (): void => {
    setInterval(updateUptime, 1000); // 每秒更新一次
  };

  const toggleTheme = (): void => {
    currentTheme.value = currentTheme.value === 'light' ? 'dark' : 'light';
    // 可以在这里添加主题切换的具体逻辑
  };

  const toggleSidebar = (): void => {
    sidebarCollapsed.value = !sidebarCollapsed.value;
  };

  const setDebugMode = (enabled: boolean): void => {
    debug.value = enabled;
    console.log(`🐛 调试模式: ${enabled ? '开启' : '关闭'}`);
  };

  // 返回响应式状态和方法
  return {
    // 状态
    debug: readonly(debug),
    version: readonly(version),
    isInitialized: readonly(isInitialized),
    startTime: readonly(startTime),
    currentUptime: readonly(currentUptime),
    platform: readonly(platform),
    tauri_version: readonly(tauri_version),
    currentTheme,
    sidebarCollapsed,
    
    // 计算属性
    uptime,
    isDebugMode,
    
    // 方法
    initialize,
    updateUptime,
    toggleTheme,
    toggleSidebar,
    setDebugMode
  };
});
```

## 📋 LogStore - 日志状态管理

### 状态定义

```typescript
interface LogState {
  // 日志数据
  logs: LogEntry[];                  // 日志列表
  filteredLogs: LogEntry[];          // 过滤后的日志
  
  // 控制状态
  isStreaming: boolean;              // 是否正在实时流
  isLoading: boolean;                // 是否正在加载
  autoScroll: boolean;               // 自动滚动开关
  
  // 过滤和配置
  currentFilters: LogFilters;        // 当前过滤条件
  maxLogEntries: number;             // 最大显示条目数
  
  // 统计信息
  stats: LogStats;                   // 日志统计
  lastUpdateTime: string;            // 最后更新时间
  error: string | null;              // 错误信息
}
```

### Store实现

```typescript
export const useLogStore = defineStore('log', () => {
  // 状态定义
  const logs = ref<LogEntry[]>([]);
  const isStreaming = ref(false);
  const isLoading = ref(false);
  const currentFilters = ref<LogFilters>({});
  const stats = ref<LogStats>({
    total_logs: 0,
    error_count: 0,
    warn_count: 0,
    info_count: 0,
    debug_count: 0,
    trace_count: 0
  });
  const maxLogEntries = ref(1000);
  const lastUpdateTime = ref('');
  const error = ref<string | null>(null);

  // 事件监听器
  let logStreamListener: any = null;

  // 计算属性
  const filteredLogs = computed(() => {
    let filtered = logs.value;

    // 按日志级别过滤
    if (currentFilters.value.level) {
      filtered = filtered.filter(log => log.level === currentFilters.value.level);
    }

    // 按关键词过滤
    if (currentFilters.value.keywords && currentFilters.value.keywords.length > 0) {
      filtered = filtered.filter(log => 
        currentFilters.value.keywords!.some(keyword => 
          log.message.toLowerCase().includes(keyword.toLowerCase()) ||
          log.target.toLowerCase().includes(keyword.toLowerCase())
        )
      );
    }

    return filtered.sort((a, b) => a.timestamp - b.timestamp);
  });

  const logLevelCounts = computed(() => {
    const counts = {
      error: 0,
      warn: 0,
      info: 0,
      debug: 0,
      trace: 0
    };

    logs.value.forEach(log => {
      if (log.level in counts) {
        counts[log.level as keyof typeof counts]++;
      }
    });

    return counts;
  });

  // 动作方法
  const loadRecentLogs = async (limit: number = 1000): Promise<void> => {
    isLoading.value = true;
    error.value = null;
    
    try {
      console.log('🔄 加载最近的日志...');
      const recentLogs = await invoke<LogEntry[]>('get_recent_logs', { 
        limit, 
        filters: Object.keys(currentFilters.value).length > 0 
          ? currentFilters.value 
          : null 
      });
      
      logs.value = recentLogs;
      lastUpdateTime.value = new Date().toLocaleTimeString();
      
      console.log(`✅ 成功加载 ${recentLogs.length} 条日志`);
    } catch (err) {
      console.error('❌ 加载日志失败:', err);
      error.value = `加载日志失败: ${err}`;
    } finally {
      isLoading.value = false;
    }
  };

  const startLogStream = async (): Promise<void> => {
    if (isStreaming.value) return;

    try {
      console.log('🚀 开始订阅日志流...');
      
      // 订阅后端日志流
      await invoke('subscribe_log_stream', { 
        filters: Object.keys(currentFilters.value).length > 0 
          ? currentFilters.value 
          : null 
      });

      // 监听日志流事件
      logStreamListener = await listen<LogEntry>('log-stream', (event) => {
        const newLog = event.payload;
        
        // 添加新日志到前端
        logs.value.push(newLog);
        
        // 保持最大数量限制
        if (logs.value.length > maxLogEntries.value) {
          logs.value = logs.value.slice(-maxLogEntries.value);
        }
        
        // 更新最后更新时间
        lastUpdateTime.value = new Date().toLocaleTimeString();
      });

      isStreaming.value = true;
      console.log('✅ 日志流订阅成功');
    } catch (err) {
      console.error('❌ 订阅日志流失败:', err);
      error.value = `订阅日志流失败: ${err}`;
    }
  };

  const stopLogStream = async (): Promise<void> => {
    if (!isStreaming.value) return;

    try {
      console.log('🛑 停止日志流订阅...');
      
      // 取消订阅后端日志流
      await invoke('unsubscribe_log_stream');
      
      // 取消前端事件监听
      if (logStreamListener) {
        logStreamListener();
        logStreamListener = null;
      }
      
      isStreaming.value = false;
      console.log('✅ 日志流订阅已停止');
    } catch (err) {
      console.error('❌ 停止日志流失败:', err);
      error.value = `停止日志流失败: ${err}`;
    }
  };

  const clearLogs = async (): Promise<void> => {
    try {
      console.log('🗑️ 清空日志...');
      
      // 清空后端日志缓冲区
      await invoke('clear_logs');
      
      // 清空前端日志
      logs.value = [];
      lastUpdateTime.value = new Date().toLocaleTimeString();
      
      console.log('✅ 日志已清空');
    } catch (err) {
      console.error('❌ 清空日志失败:', err);
      error.value = `清空日志失败: ${err}`;
    }
  };

  const updateFilters = (filters: LogFilters): void => {
    currentFilters.value = { ...filters };
    console.log('🔍 更新日志过滤器:', filters);
  };

  const getLogStats = async (): Promise<LogStats | null> => {
    try {
      const logStats = await invoke<LogStats>('get_log_stats');
      stats.value = logStats;
      return logStats;
    } catch (err) {
      console.error('❌ 获取日志统计失败:', err);
      error.value = `获取日志统计失败: ${err}`;
      return null;
    }
  };

  const cleanup = async (): Promise<void> => {
    if (isStreaming.value) {
      await stopLogStream();
    }
  };

  return {
    // 状态
    logs: readonly(logs),
    isStreaming: readonly(isStreaming),
    isLoading: readonly(isLoading),
    currentFilters: readonly(currentFilters),
    stats: readonly(stats),
    maxLogEntries,
    lastUpdateTime: readonly(lastUpdateTime),
    error: readonly(error),

    // 计算属性
    filteredLogs,
    logLevelCounts,

    // 方法
    loadRecentLogs,
    startLogStream,
    stopLogStream,
    clearLogs,
    updateFilters,
    getLogStats,
    cleanup
  };
});
```

## 🔐 AuthStore - 认证状态管理

### 状态定义

```typescript
interface AuthState {
  // Token状态
  tokenStatus: TokenStatus[];        // 所有系统的Token状态
  tokenEvents: TokenEvent[];         // Token事件历史
  
  // 系统统计
  systemStats: {
    total_systems: number;           // 总系统数
    systems_with_token: number;      // 有Token的系统数
    expired_tokens: number;          // 过期Token数
  };
  
  // 控制状态
  isLoading: boolean;                // 加载状态
  lastRefreshTime: string;           // 最后刷新时间
  autoRefresh: boolean;              // 自动刷新开关
  refreshInterval: number;           // 刷新间隔(毫秒)
}
```

### Store实现

```typescript
export const useAuthStore = defineStore('auth', () => {
  // 状态定义
  const tokenStatus = ref<TokenStatus[]>([]);
  const tokenEvents = ref<TokenEvent[]>([]);
  const systemStats = ref({
    total_systems: 0,
    systems_with_token: 0,
    expired_tokens: 0
  });
  const isLoading = ref(false);
  const lastRefreshTime = ref('');
  const autoRefresh = ref(true);
  const refreshInterval = ref(5000); // 5秒

  // 定时器
  let refreshTimer: number | null = null;
  let tokenEventListener: any = null;

  // 计算属性
  const systemsWithToken = computed(() => 
    tokenStatus.value.filter(status => status.has_token)
  );

  const expiredSystems = computed(() => 
    tokenStatus.value.filter(status => status.is_expired)
  );

  const healthySystems = computed(() => 
    tokenStatus.value.filter(status => status.has_token && !status.is_expired)
  );

  // 动作方法
  const initialize = async (): Promise<void> => {
    try {
      console.log('🔐 初始化认证状态管理...');
      
      // 设置Token事件监听
      await setupTokenEventListener();
      
      // 初始加载Token状态
      await refreshTokenStatus();
      
      // 启动自动刷新
      if (autoRefresh.value) {
        startAutoRefresh();
      }
      
      console.log('✅ 认证状态管理初始化完成');
    } catch (error) {
      console.error('❌ 认证状态管理初始化失败:', error);
      throw error;
    }
  };

  const refreshTokenStatus = async (): Promise<void> => {
    isLoading.value = true;
    
    try {
      console.log('🔄 刷新Token状态...');
      
      // 获取所有系统的Token状态
      const statuses = await invoke<TokenStatus[]>('get_all_token_status');
      tokenStatus.value = statuses;
      
      // 更新统计信息
      updateSystemStats();
      
      // 更新最后刷新时间
      lastRefreshTime.value = new Date().toLocaleTimeString();
      
      console.log(`✅ 刷新完成，共 ${statuses.length} 个系统`);
    } catch (error) {
      console.error('❌ 刷新Token状态失败:', error);
    } finally {
      isLoading.value = false;
    }
  };

  const clearSystemToken = async (systemId: string): Promise<void> => {
    try {
      console.log(`🗑️ 清除系统 ${systemId} 的Token...`);
      
      await invoke('clear_system_token', { system_id: systemId });
      
      // 刷新状态
      await refreshTokenStatus();
      
      console.log(`✅ 系统 ${systemId} 的Token已清除`);
    } catch (error) {
      console.error(`❌ 清除系统 ${systemId} Token失败:`, error);
    }
  };

  const clearAllTokens = async (): Promise<void> => {
    try {
      console.log('🗑️ 清除所有Token...');
      
      await invoke('clear_all_tokens');
      
      // 刷新状态
      await refreshTokenStatus();
      
      console.log('✅ 所有Token已清除');
    } catch (error) {
      console.error('❌ 清除所有Token失败:', error);
    }
  };

  const setupTokenEventListener = async (): Promise<void> => {
    try {
      // 设置Token事件通道
      await invoke('set_token_event_channel');
      
      // 监听Token事件
      tokenEventListener = await listen<TokenEvent>('token-event', (event) => {
        const tokenEvent = event.payload;
        
        // 添加到事件历史
        tokenEvents.value.unshift(tokenEvent);
        
        // 保持最大事件数量
        if (tokenEvents.value.length > 100) {
          tokenEvents.value = tokenEvents.value.slice(0, 100);
        }
        
        console.log('📨 收到Token事件:', tokenEvent);
        
        // 刷新Token状态
        refreshTokenStatus();
      });
      
      console.log('✅ Token事件监听器设置成功');
    } catch (error) {
      console.error('❌ 设置Token事件监听器失败:', error);
    }
  };

  const updateSystemStats = (): void => {
    systemStats.value = {
      total_systems: tokenStatus.value.length,
      systems_with_token: systemsWithToken.value.length,
      expired_tokens: expiredSystems.value.length
    };
  };

  const startAutoRefresh = (): void => {
    if (refreshTimer) return;
    
    refreshTimer = window.setInterval(() => {
      if (autoRefresh.value) {
        refreshTokenStatus();
      }
    }, refreshInterval.value);
    
    console.log(`🔄 启动自动刷新，间隔 ${refreshInterval.value}ms`);
  };

  const stopAutoRefresh = (): void => {
    if (refreshTimer) {
      clearInterval(refreshTimer);
      refreshTimer = null;
      console.log('🛑 停止自动刷新');
    }
  };

  const setAutoRefresh = (enabled: boolean): void => {
    autoRefresh.value = enabled;
    
    if (enabled) {
      startAutoRefresh();
    } else {
      stopAutoRefresh();
    }
  };

  const cleanup = async (): Promise<void> => {
    // 停止自动刷新
    stopAutoRefresh();
    
    // 取消事件监听
    if (tokenEventListener) {
      tokenEventListener();
      tokenEventListener = null;
    }
  };

  return {
    // 状态
    tokenStatus: readonly(tokenStatus),
    tokenEvents: readonly(tokenEvents),
    systemStats: readonly(systemStats),
    isLoading: readonly(isLoading),
    lastRefreshTime: readonly(lastRefreshTime),
    autoRefresh,
    refreshInterval,
    
    // 计算属性
    systemsWithToken,
    expiredSystems,
    healthySystems,
    
    // 方法
    initialize,
    refreshTokenStatus,
    clearSystemToken,
    clearAllTokens,
    setAutoRefresh,
    cleanup
  };
});
```

## 📡 ProxyStore - 抓包状态管理

### 状态定义

```typescript
interface ProxyState {
  // 捕获状态
  captureStatus: CaptureStatus | null;    // 当前捕获状态
  isCapturing: boolean;                   // 是否正在捕获
  
  // 数据包管理
  packets: PacketData[];                  // 数据包列表
  filteredPackets: PacketData[];          // 过滤后的数据包
  
  // 网络设备
  networkDevices: NetworkDevice[];        // 可用网络设备
  selectedDevice: string | null;          // 选中的设备
  
  // 过滤器
  packetFilters: PacketFilters;           // 数据包过滤器
  
  // HTTP请求
  httpRequests: HttpRequest[];            // HTTP请求列表
  
  // 统计信息
  statistics: CaptureStatistics;          // 捕获统计
}
```

### Store实现要点

```typescript
export const useProxyStore = defineStore('proxy', () => {
  // 核心方法
  const startCapture = async (deviceName: string): Promise<void> => {
    try {
      console.log(`🚀 开始在设备 ${deviceName} 上捕获...`);
      
      // 设置事件通道
      await invoke('set_status_channel');
      await invoke('set_http_channel');
      
      // 开始捕获
      await invoke('init_capture', { device_name: deviceName });
      
      // 设置事件监听
      await setupEventListeners();
      
      selectedDevice.value = deviceName;
      console.log('✅ 捕获已启动');
    } catch (error) {
      console.error('❌ 启动捕获失败:', error);
      throw error;
    }
  };

  const stopCapture = async (): Promise<void> => {
    try {
      console.log('🛑 停止捕获...');
      
      await invoke('stop_capture');
      
      // 清理事件监听
      cleanupEventListeners();
      
      selectedDevice.value = null;
      console.log('✅ 捕获已停止');
    } catch (error) {
      console.error('❌ 停止捕获失败:', error);
    }
  };
});
```

## 🔧 状态管理最佳实践

### 1. 初始化顺序

```typescript
// 在 App.vue 中的初始化顺序
onMounted(async () => {
  try {
    // 1. 首先初始化应用状态
    await appStore.initialize();
    
    // 2. 并行初始化其他状态
    await Promise.all([
      logStore.loadRecentLogs(),
      authStore.initialize(),
      proxyStore.initialize()
    ]);
    
    console.log('✅ 所有状态管理初始化完成');
  } catch (error) {
    console.error('❌ 状态管理初始化失败:', error);
  }
});
```

### 2. 错误处理模式

```typescript
// 统一的错误处理
const handleAsyncAction = async (
  action: () => Promise<void>,
  errorMessage: string
): Promise<void> => {
  try {
    await action();
  } catch (error) {
    console.error(errorMessage, error);
    // 可以在这里添加全局错误通知
    throw error;
  }
};
```

### 3. 类型安全保障

```typescript
// 严格的类型定义
interface StoreState {
  [key: string]: unknown;
}

interface StoreActions {
  [key: string]: (...args: any[]) => any;
}

// 类型守卫
const isValidLogEntry = (obj: unknown): obj is LogEntry => {
  return typeof obj === 'object' && 
         obj !== null && 
         'id' in obj && 
         'timestamp' in obj && 
         'level' in obj;
};
```

### 4. 性能优化

```typescript
// 使用计算属性进行数据过滤
const filteredData = computed(() => {
  return data.value.filter(item => filter.value(item));
});

// 防抖处理频繁更新
import { debounce } from 'lodash-es';

const debouncedUpdate = debounce((value: string) => {
  searchKeyword.value = value;
}, 300);
```

## 📊 状态持久化

### localStorage集成

```typescript
// 持久化配置
const persistentState = {
  currentTheme: 'currentTheme',
  sidebarCollapsed: 'sidebarCollapsed',
  autoRefresh: 'autoRefresh',
  maxLogEntries: 'maxLogEntries'
};

// 自动保存到localStorage
watch(currentTheme, (newTheme) => {
  localStorage.setItem(persistentState.currentTheme, newTheme);
});

// 从localStorage恢复
const restoreFromStorage = (): void => {
  const savedTheme = localStorage.getItem(persistentState.currentTheme);
  if (savedTheme) {
    currentTheme.value = savedTheme as 'light' | 'dark';
  }
};
```

## 🧪 测试支持

### Store测试示例

```typescript
// 测试设置
import { createPinia, setActivePinia } from 'pinia';
import { useLogStore } from '@/stores/logStore';

describe('LogStore', () => {
  beforeEach(() => {
    setActivePinia(createPinia());
  });

  it('应该正确初始化状态', () => {
    const logStore = useLogStore();
    
    expect(logStore.logs).toEqual([]);
    expect(logStore.isStreaming).toBe(false);
    expect(logStore.isLoading).toBe(false);
  });

  it('应该正确过滤日志', async () => {
    const logStore = useLogStore();
    
    // 设置测试数据
    logStore.logs = mockLogEntries;
    logStore.updateFilters({ level: 'error' });
    
    // 验证过滤结果
    expect(logStore.filteredLogs).toHaveLength(2);
  });
});
```

这套状态管理架构提供了：
- 🔄 **响应式更新**: Vue 3的响应式系统确保UI实时更新
- 🏗️ **模块化设计**: 每个业务领域独立的Store
- 🛡️ **类型安全**: TypeScript提供完整的类型保障
- ⚡ **性能优化**: 计算属性和防抖处理
- 🧪 **易于测试**: 清晰的状态和动作分离

通过这套状态管理系统，前端能够高效地管理复杂的应用状态，确保数据流的一致性和可维护性。